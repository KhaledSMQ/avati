!function(){"use strict";var t={d:function(e,r){for(var s in r)t.o(r,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:r[s]})},o:function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r:function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{BatchScheduler:function(){return r},batchUpdates:function(){return s}});class r{constructor(){this.batchDepth=0,this.taskQueue=[],this.isScheduled=!1,this.isShuttingDown=!1,this.currentBatchPromise=null}static getInstance(){return null===r.instance&&(r.instance=new r),r.instance}schedule(t,e={}){if(this.isShuttingDown)throw new Error("Cannot schedule tasks after shutdown has been initiated.");const{priority:r=0,onError:s,cancellationToken:n,name:i="anonymous"}=e;this.taskQueue.push({task:t,priority:r,onError:s,token:n}),((...t)=>{const e=(new Date).toISOString().slice(11,23);console.log("[BatchScheduler]",e,...t)})(`Task scheduled: ${i} (priority: ${r})`),this.taskQueue.sort(((t,e)=>e.priority-t.priority)),this.isScheduled||0!==this.batchDepth||(this.isScheduled=!0,queueMicrotask((()=>{this.currentBatchPromise=this.processQueue()})))}startBatch(){this.batchDepth++}endBatch(){if(0===this.batchDepth)throw new Error("No batch to end.");this.batchDepth--,0===this.batchDepth&&this.taskQueue.length>0&&(this.currentBatchPromise=this.processQueue())}async processQueue(){var t;if(this.isScheduled=!1,this.batchDepth>0||this.isShuttingDown)return;const e=this.taskQueue;this.taskQueue=[];for(const r of e)if(!(null===(t=r.token)||void 0===t?void 0:t.isCancelled))try{const t=r.task();t instanceof Promise?(r.promise=t,await t):r.promise=Promise.resolve()}catch(t){if(r.onError)try{r.onError(t)}catch(t){console.error("Error in onError handler:",t)}else console.error("Error in batched task:",t)}this.taskQueue.length>0&&0===this.batchDepth&&(this.isScheduled=!0,queueMicrotask((()=>this.processQueue())))}shutdown(){this.isShuttingDown=!0,this.taskQueue=[]}flush(){if(this.batchDepth>0)throw new Error("Cannot flush while in a batching context.");this.currentBatchPromise&&this.currentBatchPromise.finally(),this.taskQueue.length>0&&(this.currentBatchPromise=this.processQueue(),this.currentBatchPromise.finally())}createCancellationToken(){let t=!1;return{cancel:()=>{t=!0},get isCancelled(){return t}}}}function s(t){const e=r.getInstance();e.startBatch();try{return t()}finally{e.endBatch()}}r.instance=null,module.exports=e}();