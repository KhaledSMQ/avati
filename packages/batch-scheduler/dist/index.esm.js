var t={d:function(e,s){for(var r in s)t.o(s,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:s[r]})},o:function(t,e){return Object.prototype.hasOwnProperty.call(t,e)}},e={};t.d(e,{u:function(){return s},r:function(){return r}});class s{constructor(){this.batchDepth=0,this.taskQueue=[],this.isScheduled=!1,this.isShuttingDown=!1,this.currentBatchPromise=null}static getInstance(){return null===s.instance&&(s.instance=new s),s.instance}schedule(t,e={}){if(this.isShuttingDown)throw new Error("Cannot schedule tasks after shutdown has been initiated.");const{priority:s=0,onError:r,cancellationToken:n,name:i="anonymous"}=e;this.taskQueue.push({task:t,priority:s,onError:r,token:n}),((...t)=>{const e=(new Date).toISOString().slice(11,23);console.log("[BatchScheduler]",e,...t)})(`Task scheduled: ${i} (priority: ${s})`),this.taskQueue.sort(((t,e)=>e.priority-t.priority)),this.isScheduled||0!==this.batchDepth||(this.isScheduled=!0,queueMicrotask((()=>{this.currentBatchPromise=this.processQueue()})))}startBatch(){this.batchDepth++}endBatch(){if(0===this.batchDepth)throw new Error("No batch to end.");this.batchDepth--,0===this.batchDepth&&this.taskQueue.length>0&&(this.currentBatchPromise=this.processQueue())}async processQueue(){var t;if(this.isScheduled=!1,this.batchDepth>0||this.isShuttingDown)return;const e=this.taskQueue;this.taskQueue=[];for(const s of e)if(!(null===(t=s.token)||void 0===t?void 0:t.isCancelled))try{const t=s.task();t instanceof Promise?(s.promise=t,await t):s.promise=Promise.resolve()}catch(t){if(s.onError)try{s.onError(t)}catch(t){console.error("Error in onError handler:",t)}else console.error("Error in batched task:",t)}this.taskQueue.length>0&&0===this.batchDepth&&(this.isScheduled=!0,queueMicrotask((()=>this.processQueue())))}shutdown(){this.isShuttingDown=!0,this.taskQueue=[]}flush(){if(this.batchDepth>0)throw new Error("Cannot flush while in a batching context.");this.currentBatchPromise&&this.currentBatchPromise.finally(),this.taskQueue.length>0&&(this.currentBatchPromise=this.processQueue(),this.currentBatchPromise.finally())}createCancellationToken(){let t=!1;return{cancel:()=>{t=!0},get isCancelled(){return t}}}}function r(t){const e=s.getInstance();e.startBatch();try{return t()}finally{e.endBatch()}}s.instance=null;var n=e.u,i=e.r;export{n as BatchScheduler,i as batchUpdates};