{"version":3,"file":"index.umd.min.js","mappings":"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","sources":["webpack://Avati/webpack/universalModuleDefinition","webpack://Avati/webpack/bootstrap","webpack://Avati/webpack/runtime/define property getters","webpack://Avati/webpack/runtime/hasOwnProperty shorthand","webpack://Avati/webpack/runtime/make namespace object","webpack://Avati/./src/dev.ts","webpack://Avati/./src/batch-scheduler.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Avati\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Avati\"] = factory();\n\telse\n\t\troot[\"Avati\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\ndeclare global {\n    let __DEV__: boolean;\n    let __SILENT__: boolean;\n    let __VERSION__: string;\n    let __PACKAGE_NAME__: string;\n    let __TEST__: boolean;\n    let __BROWSER__: boolean;\n}\n\nexport const isDev = __DEV__;\n\nexport function assert(condition: any, message: string): asserts condition {\n    if (__DEV__ && !condition) {\n        throw new Error(message);\n    }\n}\n\nexport function warn(message: string): void {\n    if (__DEV__) {\n        console.warn(`[${__PACKAGE_NAME__}]: ${message}`);\n    }\n}\n\nexport function debugLog(message: string, ...args: any[]): void {\n    if (__DEV__ && !__SILENT__) {\n        const now = new Date();\n        // @ts-ignore\n        const timeWithMs = now.toISOString().split('T')[1].slice(0, -1);\n        console.log(`${timeWithMs} [${__PACKAGE_NAME__}@${__VERSION__}]: ${message}`, ...args);\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { debugLog } from './dev';\n\n/**\n * Type definitions for task functions and priorities.\n */\ntype TaskFunction = () => void | Promise<void>;\ntype Priority = number;\n\n/**\n * Interface representing the options available when scheduling a task.\n */\ninterface TaskOptions {\n    /**\n     * The priority level of the task. Higher numbers indicate higher priority.\n     * @default 0\n     */\n    priority?: Priority;\n\n    /**\n     * Callback function to handle any errors that occur during task execution.\n     */\n    onError?: (error: unknown) => void;\n\n    /**\n     * A cancellation token that can be used to cancel the scheduled task before it executes.\n     */\n    cancellationToken?: CancellationToken;\n\n    /**\n     * The name of the task. This is used for debugging purposes.\n     */\n    name?: string;\n}\n\n/**\n * Interface representing a scheduled task within the task queue.\n */\ninterface ScheduledTask {\n    task: TaskFunction;\n    priority: Priority;\n    onError?: (error: unknown) => void;\n    token?: CancellationToken;\n    promise?: Promise<void>;\n    name?: string;\n}\n\n/**\n * Interface representing a cancellation token for a scheduled task.\n */\ninterface CancellationToken {\n    /**\n     * Cancels the scheduled task.\n     */\n    cancel: () => void;\n\n    /**\n     * Indicates whether the task has been cancelled.\n     */\n    isCancelled: boolean;\n}\n\n\n/**\n * BatchScheduler is responsible for managing and executing tasks in batches.\n * It supports task prioritization, cancellation, error handling, and batching contexts.\n *\n * @example\n * // Retrieve the singleton instance\n * const scheduler = BatchScheduler.getInstance();\n *\n * // Schedule a task\n * scheduler.schedule(() => {\n *     console.debug('Task executed.');\n * });\n *\n * // Schedule a high-priority task\n * scheduler.schedule(() => {\n *     console.debug('High-priority task executed.');\n * }, { priority: 10 });\n *\n * // Start a batching context\n * scheduler.startBatch();\n *\n * // Schedule tasks within the batch\n * scheduler.schedule(() => {\n *     console.debug('Task within batch.');\n * });\n *\n * // End the batching context to process tasks\n * scheduler.endBatch();\n *\n * // Flush pending tasks immediately\n * scheduler.flush();\n *\n * // Shutdown the scheduler\n * scheduler.shutdown();\n */\nexport class BatchScheduler {\n    /**\n     * Singleton instance of the BatchScheduler.\n     */\n    private static instance: BatchScheduler | null = null;\n\n    /**\n     * Depth of the current batching context.\n     */\n    private batchDepth = 0;\n\n    /**\n     * Queue of tasks scheduled for execution.\n     */\n    private taskQueue: ScheduledTask[] = [];\n\n    /**\n     * Indicates whether the task queue is scheduled for processing.\n     */\n    private isScheduled = false;\n\n    /**\n     * Indicates whether the scheduler is shutting down.\n     */\n    private isShuttingDown = false;\n\n    /**\n     * Current batch promise.\n     * @private\n     */\n    private currentBatchPromise: Promise<void> | null = null;\n\n\n    /**\n     * Retrieves the singleton instance of the BatchScheduler.\n     *\n     * @returns {BatchScheduler} The singleton instance.\n     *\n     * @example\n     * const scheduler = BatchScheduler.getInstance();\n     */\n    public static getInstance(): BatchScheduler {\n        if (BatchScheduler.instance === null) {\n            BatchScheduler.instance = new BatchScheduler();\n        }\n\n        return BatchScheduler.instance;\n    }\n\n    /**\n     * Schedules a task for execution. Supports task prioritization, cancellation, and error handling.\n     *\n     * @param {TaskFunction} task - The function to be executed.\n     * @param {TaskOptions} [options={}] - Optional settings for the task.\n     *\n     * @throws {Error} If the scheduler is shutting down.\n     *\n     * @example\n     * // Schedule a simple task\n     * scheduler.schedule(() => {\n     *     console.debug('Task executed.');\n     * });\n     *\n     * @example\n     * // Schedule a task with high priority\n     * scheduler.schedule(() => {\n     *     console.debug('High-priority task executed.');\n     * }, { priority: 5 });\n     *\n     * @example\n     * // Schedule a task with an error handler\n     * scheduler.schedule(() => {\n     *     throw new Error('Task error');\n     * }, {\n     *     onError: (error) => {\n     *         console.error('Handled task error:', error);\n     *     },\n     * });\n     *\n     * @example\n     * // Schedule a task with a cancellation token\n     * const token = scheduler.createCancellationToken();\n     * scheduler.schedule(() => {\n     *     console.debug('This task may be cancelled.');\n     * }, { cancellationToken: token });\n     *\n     * // Cancel the task before it executes\n     * token.cancel();\n     */\n    public schedule(task: TaskFunction, options: TaskOptions = {}): void {\n        if (this.isShuttingDown) {\n            throw new Error('Cannot schedule tasks after shutdown has been initiated.');\n        }\n        options.name = options.name || 'anonymous';\n\n        const {\n            priority = 0,\n            onError,\n            cancellationToken: token,\n            name = 'anonymous',\n        } = options;\n\n        this.taskQueue.push({ task, priority, onError, token });\n        debugLog(`Task scheduled: ${name} (priority: ${priority})`);\n        // Sort the task queue by priority in descending order.\n        this.taskQueue.sort((a, b) => b.priority - a.priority);\n\n        if (!this.isScheduled && this.batchDepth === 0) {\n            this.isScheduled = true;\n            queueMicrotask(() => {\n                this.currentBatchPromise = this.processQueue();\n            });\n        }\n    }\n\n    /**\n     * Begins a new batching context. Tasks scheduled within this context\n     * will be deferred until the batch ends.\n     *\n     * @example\n     * scheduler.startBatch();\n     * // Schedule tasks within the batch\n     * scheduler.schedule(() => {\n     *     console.debug('Task within batch.');\n     * });\n     * // End the batching context\n     * scheduler.endBatch();\n     */\n    public startBatch(): void {\n        this.batchDepth++;\n    }\n\n    /**\n     * Ends the current batching context. If all batching contexts have ended,\n     * pending tasks will be processed.\n     *\n     * @throws {Error} If there is no batching context to end.\n     *\n     * @example\n     * // Assuming a batching context has been started\n     * scheduler.endBatch();\n     */\n    public endBatch(): void {\n        if (this.batchDepth === 0) {\n            throw new Error('No batch to end.');\n        }\n\n        this.batchDepth--;\n\n        if (this.batchDepth === 0 && this.taskQueue.length > 0) {\n            debugLog(`Batch ended, processing tasks (${this.taskQueue.length})`);\n            this.currentBatchPromise = this.processQueue();\n        }\n    }\n\n    /**\n     * Processes the task queue, executing tasks in order of priority.\n     */\n    private async processQueue(): Promise<void> {\n        this.isScheduled = false;\n\n        if (this.batchDepth > 0 || this.isShuttingDown) {\n            debugLog(\"Batch depth is greater than 0 or shutting down, returning\");\n            return;\n        }\n\n        const tasksToProcess = this.taskQueue;\n        this.taskQueue = [];\n\n        for (const scheduledTask of tasksToProcess) {\n            if (scheduledTask.token?.isCancelled) {\n                debugLog(\"Task is cancelled, skipping\");\n                continue;\n            }\n\n            try {\n                const result = scheduledTask.task();\n\n                // If the task returns a promise, we need to wait for it\n                if (result instanceof Promise) {\n                    scheduledTask.promise = result;\n                    await result;\n                    debugLog(`Task completed: ${scheduledTask.name}`);\n                } else {\n                    // For synchronous tasks, we create a resolved promise\n                    scheduledTask.promise = Promise.resolve();\n                }\n            } catch (error) {\n                debugLog(`Task failed: ${scheduledTask.name}`);\n                if (scheduledTask.onError) {\n                    try {\n                        scheduledTask.onError(error);\n                    } catch (errorInHandler) {\n                        console.error('Error in onError handler:', errorInHandler);\n                    }\n                } else {\n                    console.error('Error in batched task:', error);\n                }\n            }\n        }\n\n        if (this.taskQueue.length > 0 && this.batchDepth === 0) {\n            debugLog(\"Task queue is not empty, scheduling next batch\");\n            this.isScheduled = true;\n            queueMicrotask(() => this.processQueue());\n        }\n    }\n\n    /**\n     * Cancels all pending tasks and prevents new tasks from being scheduled.\n     *\n     * @example\n     * scheduler.shutdown();\n     */\n    public shutdown(): void {\n        debugLog('Shutting down scheduler');\n        this.isShuttingDown = true;\n        this.taskQueue = [];\n    }\n\n    /**\n     * Immediately processes all pending tasks in the queue.\n     *\n     * @throws {Error} If called within a batching context.\n     *\n     * @example\n     * scheduler.flush();\n     */\n    public flush(): void {\n        debugLog('Flushing scheduler');\n        if (this.batchDepth > 0) {\n            throw new Error('Cannot flush while in a batching context.');\n        }\n\n        // Trigger completion of current batch without blocking\n        if (this.currentBatchPromise) {\n            debugLog('Completing current batch');\n            this.currentBatchPromise.finally()\n        }\n\n        // Process any remaining tasks without blocking\n        if (this.taskQueue.length > 0) {\n            debugLog('Processing remaining tasks');\n            this.currentBatchPromise = this.processQueue();\n            this.currentBatchPromise.finally();\n        }\n    }\n\n    /**\n     * Creates a cancellation token that can be used to cancel a scheduled task.\n     *\n     * @returns {CancellationToken} A new cancellation token.\n     *\n     * @example\n     * const token = scheduler.createCancellationToken();\n     * scheduler.schedule(() => {\n     *     console.debug('This task may be cancelled.');\n     * }, { cancellationToken: token });\n     *\n     * // Cancel the task before it executes\n     * token.cancel();\n     */\n    public createCancellationToken(): CancellationToken {\n        let isCancelled = false;\n\n        return {\n            cancel: () => {\n                isCancelled = true;\n            },\n            get isCancelled() {\n                return isCancelled;\n            },\n        };\n    }\n}\n\n/**\n * Executes a function within a batching context. Tasks scheduled within the function\n * will be deferred until the batch ends.\n *\n * @param {() => T} fn - The function to execute.\n *\n * @returns {T} The return value of the executed function.\n *\n * @template T\n *\n * @example\n * batchUpdates(() => {\n *     // Schedule tasks within the batch\n *     scheduler.schedule(() => {\n *         console.debug('Task within batch.');\n *     });\n *     // Other synchronous operations\n *     console.debug('Batching operations complete.');\n * });\n */\nexport function batchUpdates<T>(fn: () => T): T {\n    const scheduler = BatchScheduler.getInstance();\n    debugLog('Starting batch...');\n    scheduler.startBatch();\n\n    try {\n        return fn();\n    } finally {\n        scheduler.endBatch();\n        debugLog('Batch ended.');\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","debugLog","message","args","BatchScheduler","batchDepth","taskQueue","isScheduled","isShuttingDown","currentBatchPromise","getInstance","instance","schedule","task","options","Error","name","priority","onError","cancellationToken","token","push","sort","a","b","queueMicrotask","processQueue","startBatch","endBatch","length","tasksToProcess","scheduledTask","isCancelled","result","Promise","promise","resolve","error","errorInHandler","console","shutdown","flush","finally","createCancellationToken","cancel","batchUpdates","fn","scheduler"],"sourceRoot":""}