{"version":3,"file":"index.esm.min.js","mappings":"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","sources":["webpack://@avati/batch-scheduler/webpack/bootstrap","webpack://@avati/batch-scheduler/webpack/runtime/define property getters","webpack://@avati/batch-scheduler/webpack/runtime/hasOwnProperty shorthand","webpack://@avati/batch-scheduler/./src/dev.ts","webpack://@avati/batch-scheduler/./src/batch-scheduler.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\ndeclare global {\n    let __DEV__: boolean;\n    let __SILENT__: boolean;\n    let __VERSION__: string;\n    let __PACKAGE_NAME__: string;\n    let __TEST__: boolean;\n    let __BROWSER__: boolean;\n}\n\nexport const isDev = __DEV__;\n\nexport function assert(condition: any, message: string): asserts condition {\n    if (__DEV__ && !condition) {\n        throw new Error(message);\n    }\n}\n\nexport function warn(message: string): void {\n    if (__DEV__) {\n        console.warn(`[${__PACKAGE_NAME__}]: ${message}`);\n    }\n}\n\nexport function debugLog(message: string, ...args: any[]): void {\n    if (__DEV__ && !__SILENT__) {\n        const now = new Date();\n        // @ts-ignore\n        const timeWithMs = now.toISOString().split('T')[1].slice(0, -1);\n        console.log(`${timeWithMs} [${__PACKAGE_NAME__}@${__VERSION__}]: ${message}`, ...args);\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { debugLog } from './dev';\n\n/**\n * Type definitions for task functions and priorities.\n */\ntype TaskFunction = () => void | Promise<void>;\ntype Priority = number;\n\n/**\n * Interface representing the options available when scheduling a task.\n */\ninterface TaskOptions {\n    /**\n     * The priority level of the task. Higher numbers indicate higher priority.\n     * @default 0\n     */\n    priority?: Priority;\n\n    /**\n     * Callback function to handle any errors that occur during task execution.\n     */\n    onError?: (error: unknown) => void;\n\n    /**\n     * A cancellation token that can be used to cancel the scheduled task before it executes.\n     */\n    cancellationToken?: CancellationToken;\n\n    /**\n     * The name of the task. This is used for debugging purposes.\n     */\n    name?: string;\n}\n\n/**\n * Interface representing a scheduled task within the task queue.\n */\ninterface ScheduledTask {\n    task: TaskFunction;\n    priority: Priority;\n    onError?: (error: unknown) => void;\n    token?: CancellationToken;\n    promise?: Promise<void>;\n    name?: string;\n}\n\n/**\n * Interface representing a cancellation token for a scheduled task.\n */\ninterface CancellationToken {\n    /**\n     * Cancels the scheduled task.\n     */\n    cancel: () => void;\n\n    /**\n     * Indicates whether the task has been cancelled.\n     */\n    isCancelled: boolean;\n}\n\n\n/**\n * BatchScheduler is responsible for managing and executing tasks in batches.\n * It supports task prioritization, cancellation, error handling, and batching contexts.\n *\n * @example\n * // Retrieve the singleton instance\n * const scheduler = BatchScheduler.getInstance();\n *\n * // Schedule a task\n * scheduler.schedule(() => {\n *     console.debug('Task executed.');\n * });\n *\n * // Schedule a high-priority task\n * scheduler.schedule(() => {\n *     console.debug('High-priority task executed.');\n * }, { priority: 10 });\n *\n * // Start a batching context\n * scheduler.startBatch();\n *\n * // Schedule tasks within the batch\n * scheduler.schedule(() => {\n *     console.debug('Task within batch.');\n * });\n *\n * // End the batching context to process tasks\n * scheduler.endBatch();\n *\n * // Flush pending tasks immediately\n * scheduler.flush();\n *\n * // Shutdown the scheduler\n * scheduler.shutdown();\n */\nexport class BatchScheduler {\n    /**\n     * Singleton instance of the BatchScheduler.\n     */\n    private static instance: BatchScheduler | null = null;\n\n    /**\n     * Depth of the current batching context.\n     */\n    private batchDepth = 0;\n\n    /**\n     * Queue of tasks scheduled for execution.\n     */\n    private taskQueue: ScheduledTask[] = [];\n\n    /**\n     * Indicates whether the task queue is scheduled for processing.\n     */\n    private isScheduled = false;\n\n    /**\n     * Indicates whether the scheduler is shutting down.\n     */\n    private isShuttingDown = false;\n\n    /**\n     * Current batch promise.\n     * @private\n     */\n    private currentBatchPromise: Promise<void> | null = null;\n\n\n    /**\n     * Retrieves the singleton instance of the BatchScheduler.\n     *\n     * @returns {BatchScheduler} The singleton instance.\n     *\n     * @example\n     * const scheduler = BatchScheduler.getInstance();\n     */\n    public static getInstance(): BatchScheduler {\n        if (BatchScheduler.instance === null) {\n            BatchScheduler.instance = new BatchScheduler();\n        }\n\n        return BatchScheduler.instance;\n    }\n\n    /**\n     * Schedules a task for execution. Supports task prioritization, cancellation, and error handling.\n     *\n     * @param {TaskFunction} task - The function to be executed.\n     * @param {TaskOptions} [options={}] - Optional settings for the task.\n     *\n     * @throws {Error} If the scheduler is shutting down.\n     *\n     * @example\n     * // Schedule a simple task\n     * scheduler.schedule(() => {\n     *     console.debug('Task executed.');\n     * });\n     *\n     * @example\n     * // Schedule a task with high priority\n     * scheduler.schedule(() => {\n     *     console.debug('High-priority task executed.');\n     * }, { priority: 5 });\n     *\n     * @example\n     * // Schedule a task with an error handler\n     * scheduler.schedule(() => {\n     *     throw new Error('Task error');\n     * }, {\n     *     onError: (error) => {\n     *         console.error('Handled task error:', error);\n     *     },\n     * });\n     *\n     * @example\n     * // Schedule a task with a cancellation token\n     * const token = scheduler.createCancellationToken();\n     * scheduler.schedule(() => {\n     *     console.debug('This task may be cancelled.');\n     * }, { cancellationToken: token });\n     *\n     * // Cancel the task before it executes\n     * token.cancel();\n     */\n    public schedule(task: TaskFunction, options: TaskOptions = {}): void {\n        if (this.isShuttingDown) {\n            throw new Error('Cannot schedule tasks after shutdown has been initiated.');\n        }\n        options.name = options.name || 'anonymous';\n\n        const {\n            priority = 0,\n            onError,\n            cancellationToken: token,\n            name = 'anonymous',\n        } = options;\n\n        this.taskQueue.push({ task, priority, onError, token });\n        debugLog(`Task scheduled: ${name} (priority: ${priority})`);\n        // Sort the task queue by priority in descending order.\n        this.taskQueue.sort((a, b) => b.priority - a.priority);\n\n        if (!this.isScheduled && this.batchDepth === 0) {\n            this.isScheduled = true;\n            queueMicrotask(() => {\n                this.currentBatchPromise = this.processQueue();\n            });\n        }\n    }\n\n    /**\n     * Begins a new batching context. Tasks scheduled within this context\n     * will be deferred until the batch ends.\n     *\n     * @example\n     * scheduler.startBatch();\n     * // Schedule tasks within the batch\n     * scheduler.schedule(() => {\n     *     console.debug('Task within batch.');\n     * });\n     * // End the batching context\n     * scheduler.endBatch();\n     */\n    public startBatch(): void {\n        this.batchDepth++;\n    }\n\n    /**\n     * Ends the current batching context. If all batching contexts have ended,\n     * pending tasks will be processed.\n     *\n     * @throws {Error} If there is no batching context to end.\n     *\n     * @example\n     * // Assuming a batching context has been started\n     * scheduler.endBatch();\n     */\n    public endBatch(): void {\n        if (this.batchDepth === 0) {\n            throw new Error('No batch to end.');\n        }\n\n        this.batchDepth--;\n\n        if (this.batchDepth === 0 && this.taskQueue.length > 0) {\n            debugLog(`Batch ended, processing tasks (${this.taskQueue.length})`);\n            this.currentBatchPromise = this.processQueue();\n        }\n    }\n\n    /**\n     * Processes the task queue, executing tasks in order of priority.\n     */\n    private async processQueue(): Promise<void> {\n        this.isScheduled = false;\n\n        if (this.batchDepth > 0 || this.isShuttingDown) {\n            debugLog(\"Batch depth is greater than 0 or shutting down, returning\");\n            return;\n        }\n\n        const tasksToProcess = this.taskQueue;\n        this.taskQueue = [];\n\n        for (const scheduledTask of tasksToProcess) {\n            if (scheduledTask.token?.isCancelled) {\n                debugLog(\"Task is cancelled, skipping\");\n                continue;\n            }\n\n            try {\n                const result = scheduledTask.task();\n\n                // If the task returns a promise, we need to wait for it\n                if (result instanceof Promise) {\n                    scheduledTask.promise = result;\n                    await result;\n                    debugLog(`Task completed: ${scheduledTask.name}`);\n                } else {\n                    // For synchronous tasks, we create a resolved promise\n                    scheduledTask.promise = Promise.resolve();\n                }\n            } catch (error) {\n                debugLog(`Task failed: ${scheduledTask.name}`);\n                if (scheduledTask.onError) {\n                    try {\n                        scheduledTask.onError(error);\n                    } catch (errorInHandler) {\n                        console.error('Error in onError handler:', errorInHandler);\n                    }\n                } else {\n                    console.error('Error in batched task:', error);\n                }\n            }\n        }\n\n        if (this.taskQueue.length > 0 && this.batchDepth === 0) {\n            debugLog(\"Task queue is not empty, scheduling next batch\");\n            this.isScheduled = true;\n            queueMicrotask(() => this.processQueue());\n        }\n    }\n\n    /**\n     * Cancels all pending tasks and prevents new tasks from being scheduled.\n     *\n     * @example\n     * scheduler.shutdown();\n     */\n    public shutdown(): void {\n        debugLog('Shutting down scheduler');\n        this.isShuttingDown = true;\n        this.taskQueue = [];\n    }\n\n    /**\n     * Immediately processes all pending tasks in the queue.\n     *\n     * @throws {Error} If called within a batching context.\n     *\n     * @example\n     * scheduler.flush();\n     */\n    public flush(): void {\n        debugLog('Flushing scheduler');\n        if (this.batchDepth > 0) {\n            throw new Error('Cannot flush while in a batching context.');\n        }\n\n        // Trigger completion of current batch without blocking\n        if (this.currentBatchPromise) {\n            debugLog('Completing current batch');\n            this.currentBatchPromise.finally()\n        }\n\n        // Process any remaining tasks without blocking\n        if (this.taskQueue.length > 0) {\n            debugLog('Processing remaining tasks');\n            this.currentBatchPromise = this.processQueue();\n            this.currentBatchPromise.finally();\n        }\n    }\n\n    /**\n     * Creates a cancellation token that can be used to cancel a scheduled task.\n     *\n     * @returns {CancellationToken} A new cancellation token.\n     *\n     * @example\n     * const token = scheduler.createCancellationToken();\n     * scheduler.schedule(() => {\n     *     console.debug('This task may be cancelled.');\n     * }, { cancellationToken: token });\n     *\n     * // Cancel the task before it executes\n     * token.cancel();\n     */\n    public createCancellationToken(): CancellationToken {\n        let isCancelled = false;\n\n        return {\n            cancel: () => {\n                isCancelled = true;\n            },\n            get isCancelled() {\n                return isCancelled;\n            },\n        };\n    }\n}\n\n/**\n * Executes a function within a batching context. Tasks scheduled within the function\n * will be deferred until the batch ends.\n *\n * @param {() => T} fn - The function to execute.\n *\n * @returns {T} The return value of the executed function.\n *\n * @template T\n *\n * @example\n * batchUpdates(() => {\n *     // Schedule tasks within the batch\n *     scheduler.schedule(() => {\n *         console.debug('Task within batch.');\n *     });\n *     // Other synchronous operations\n *     console.debug('Batching operations complete.');\n * });\n */\nexport function batchUpdates<T>(fn: () => T): T {\n    const scheduler = BatchScheduler.getInstance();\n    debugLog('Starting batch...');\n    scheduler.startBatch();\n\n    try {\n        return fn();\n    } finally {\n        scheduler.endBatch();\n        debugLog('Batch ended.');\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","debugLog","message","args","BatchScheduler","batchDepth","taskQueue","isScheduled","isShuttingDown","currentBatchPromise","getInstance","instance","schedule","task","options","this","Error","name","priority","onError","cancellationToken","token","push","sort","a","b","queueMicrotask","processQueue","startBatch","endBatch","length","tasksToProcess","scheduledTask","isCancelled","result","Promise","promise","resolve","error","errorInHandler","console","shutdown","flush","finally","createCancellationToken","cancel","batchUpdates","fn","scheduler"],"sourceRoot":""}