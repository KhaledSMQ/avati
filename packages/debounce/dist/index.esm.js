var e={d:function(r,n){for(var o in n)e.o(n,o)&&!e.o(r,o)&&Object.defineProperty(r,o,{enumerable:!0,get:n[o]})},o:function(e,r){return Object.prototype.hasOwnProperty.call(e,r)}},r={};e.d(r,{s:function(){return t}});const n=new WeakMap,o=e=>({log:(...r)=>e&&console.log("[Debounce]",...r),warn:(...r)=>e&&console.warn("[Debounce]",...r),error:(...r)=>e&&console.error("[Debounce]",...r)});function t(e,r={}){if("function"!=typeof e)throw new TypeError("Expected a function");const{wait:t=0,leading:i=!1,trailing:a=!0,maxWait:l,debug:s=!1,signal:c,onError:d}=r;if(t<0||void 0!==l&&l<t)throw new RangeError("Invalid wait/maxWait values");if(!i&&!a)throw new Error("At least one of leading or trailing must be true");const u=o(s),m={lastInvokeTime:0,pendingPromises:[],aborted:!1};function g(){void 0!==m.timerId&&(clearTimeout(m.timerId),m.timerId=void 0,u.log("Cleared debounce timer")),void 0!==m.maxTimerId&&(clearTimeout(m.maxTimerId),m.maxTimerId=void 0,u.log("Cleared max wait timer"))}function f(){u.log("Cancelling pending invocations"),g(),m.lastInvokeTime=0,m.lastArgs=void 0,m.lastThis=void 0,m.lastCallTime=void 0;v(new Error("Debounced function cancelled")),m.pendingPromises.forEach((({reject:e})=>e(new Error("Debounced function cancelled")))),m.pendingPromises=[]}function v(e){if(u.error("Error occurred:",e),d)try{d(e)}catch(e){u.error("Error in onError callback:",e)}}function b(){return void 0!==m.timerId}function p(e){if(m.aborted)return!1;const r=void 0===m.lastCallTime?0:e-m.lastCallTime,n=e-m.lastInvokeTime;return void 0===m.lastCallTime||r>=t||r<0||void 0!==l&&n>=l}async function T(r){u.log(`Invoking function at ${r}`),m.lastInvokeTime=r;const n=m.lastArgs,o=m.lastThis;m.lastArgs=void 0,m.lastThis=void 0;try{const r=await e.apply(o,n);return m.result=r,m.pendingPromises.forEach((({resolve:e})=>e(r))),m.pendingPromises=[],u.log("Function invoked successfully",r),r}catch(e){const r=e instanceof Error?e:new Error(String(e));u.error("Error in function invocation:",r),v(r);const n=[...m.pendingPromises];m.pendingPromises=[],n.forEach((({reject:e})=>e(r)))}}function w(e){const r=function(e){const r=m.lastCallTime?e-m.lastCallTime:0;return Math.max(0,t-r)}(e);if(m.timerId=setTimeout(h,r),u.log(`Started debounce timer for ${r}ms`),void 0!==l&&!m.maxTimerId){const r=l-(e-m.lastCallTime);m.maxTimerId=setTimeout((()=>{u.log("Max wait timer expired"),g(),T(Date.now())}),Math.max(0,r)),u.log(`Started max wait timer for ${r}ms`)}}function h(){const e=Date.now();if(u.log("Debounce timer expired"),p(e))return function(e){u.log("Trailing edge triggered"),g(),a&&m.lastArgs?T(e):(m.pendingPromises.forEach((({resolve:e})=>{e(m.result)})),m.pendingPromises=[])}(e);w(e)}c&&c.addEventListener("abort",(()=>{m.aborted=!0,f()}));const E=function(...e){if(m.aborted)return Promise.reject(new Error("Debounced function aborted"));const r=Date.now(),n=p(r);return m.lastArgs=e,m.lastThis=this,m.lastCallTime=r,u.log("Function called",{time:r,isInvoking:n,args:e,pending:b()}),new Promise(((e,n)=>{m.pendingPromises.push({resolve:e,reject:n}),void 0===m.timerId?function(e){u.log("Leading edge triggered"),m.lastInvokeTime=e,w(e),i&&T(e)}(r):(g(),w(r))}))};return n.set(E,m),Object.defineProperties(E,{cancel:{value:f,writable:!1,configurable:!1},flush:{value:async function(...e){u.log("Flush requested");const r=e.length>0?e:m.lastArgs,n=m.lastThis;return g(),r?(m.lastArgs=r,m.lastThis=n,T(Date.now())):Promise.resolve(m.result)},writable:!1,configurable:!1},pending:{value:b,writable:!1,configurable:!1},cleanup:{value:function(){u.log("Cleanup initiated"),f(),n.delete(E)},writable:!1,configurable:!1}}),E}var i=r.s;export{i as debounce};