const privateState=new WeakMap,createLogger=e=>({log:(...r)=>e&&console.log("[Debounce]",...r),warn:(...r)=>e&&console.warn("[Debounce]",...r),error:(...r)=>e&&console.error("[Debounce]",...r)});function debounce(e,r={}){if("function"!=typeof e)throw new TypeError("Expected a function");const{wait:n=0,leading:o=!1,trailing:t=!0,maxWait:i,debug:a=!1,signal:l,onError:s}=r;if(n<0||void 0!==i&&i<n)throw new RangeError("Invalid wait/maxWait values");if(!o&&!t)throw new Error("At least one of leading or trailing must be true");const c=createLogger(a),d={lastInvokeTime:0,pendingPromises:[],aborted:!1};function u(){void 0!==d.timerId&&(clearTimeout(d.timerId),d.timerId=void 0,c.log("Cleared debounce timer")),void 0!==d.maxTimerId&&(clearTimeout(d.maxTimerId),d.maxTimerId=void 0,c.log("Cleared max wait timer"))}function g(){c.log("Cancelling pending invocations"),u(),d.lastInvokeTime=0,d.lastArgs=void 0,d.lastThis=void 0,d.lastCallTime=void 0;m(new Error("Debounced function cancelled")),d.pendingPromises.forEach((({reject:e})=>e(new Error("Debounced function cancelled")))),d.pendingPromises=[]}function m(e){if(c.error("Error occurred:",e),s)try{s(e)}catch(e){c.error("Error in onError callback:",e)}}function f(){return void 0!==d.timerId}function v(e){if(d.aborted)return!1;const r=void 0===d.lastCallTime?0:e-d.lastCallTime,o=e-d.lastInvokeTime;return void 0===d.lastCallTime||r>=n||r<0||void 0!==i&&o>=i}async function T(r){c.log(`Invoking function at ${r}`),d.lastInvokeTime=r;const n=d.lastArgs,o=d.lastThis;d.lastArgs=void 0,d.lastThis=void 0;try{const r=await e.apply(o,n);return d.result=r,d.pendingPromises.forEach((({resolve:e})=>e(r))),d.pendingPromises=[],c.log("Function invoked successfully",r),r}catch(e){const r=e instanceof Error?e:new Error(String(e));c.error("Error in function invocation:",r),m(r);const n=[...d.pendingPromises];d.pendingPromises=[],n.forEach((({reject:e})=>e(r)))}}function b(e){const r=function(e){const r=d.lastCallTime?e-d.lastCallTime:0;return Math.max(0,n-r)}(e);if(d.timerId=setTimeout(p,r),c.log(`Started debounce timer for ${r}ms`),void 0!==i&&!d.maxTimerId){const r=i-(e-d.lastCallTime);d.maxTimerId=setTimeout((()=>{c.log("Max wait timer expired"),u(),T(Date.now())}),Math.max(0,r)),c.log(`Started max wait timer for ${r}ms`)}}function p(){const e=Date.now();if(c.log("Debounce timer expired"),v(e))return function(e){c.log("Trailing edge triggered"),u(),t&&d.lastArgs?T(e):(d.pendingPromises.forEach((({resolve:e})=>{e(d.result)})),d.pendingPromises=[])}(e);b(e)}l&&l.addEventListener("abort",(()=>{d.aborted=!0,g()}));const w=function(...e){if(d.aborted)return Promise.reject(new Error("Debounced function aborted"));const r=Date.now(),n=v(r);return d.lastArgs=e,d.lastThis=this,d.lastCallTime=r,c.log("Function called",{time:r,isInvoking:n,args:e,pending:f()}),new Promise(((e,n)=>{d.pendingPromises.push({resolve:e,reject:n}),void 0===d.timerId?function(e){c.log("Leading edge triggered"),d.lastInvokeTime=e,b(e),o&&T(e)}(r):(u(),b(r))}))};return privateState.set(w,d),Object.defineProperties(w,{cancel:{value:g,writable:!1,configurable:!1},flush:{value:async function(...e){c.log("Flush requested");const r=e.length>0?e:d.lastArgs,n=d.lastThis;return u(),r?(d.lastArgs=r,d.lastThis=n,T(Date.now())):Promise.resolve(d.result)},writable:!1,configurable:!1},pending:{value:f,writable:!1,configurable:!1},cleanup:{value:function(){c.log("Cleanup initiated"),g(),privateState.delete(w)},writable:!1,configurable:!1}}),w}export{debounce};