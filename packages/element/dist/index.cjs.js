!function(){"use strict";var t={d:function(e,n){for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r:function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function n(t){const e="string"==typeof t?document.querySelector(t):t;if(!e)throw new Error("Element not found");const n=window.getComputedStyle(e);return{top:o(n.marginTop),right:o(n.marginRight),bottom:o(n.marginBottom),left:o(n.marginLeft),all:n.margin}}function i(t,e){return n(t)[e]}function o(t){return parseInt(t,10)||0}function r(t){const e=n(t);return Object.values(e).some((t=>"number"==typeof t&&t>0))}function u(t){const e=n(t);return e.left+e.right}function a(t){const e=n(t);return e.top+e.bottom}t.r(e),t.d(e,{BoundaryCalculationError:function(){return d},ChildViewElement:function(){return c},GetElementBounds:function(){return s},ViewBoundaryCalculator:function(){return h},addEventListenerToElement:function(){return v},appendChildToElement:function(){return E},clearElementChildren:function(){return N},createElement:function(){return p},createSvgElement:function(){return w},getHorizontalMargin:function(){return u},getMargin:function(){return i},getMargins:function(){return n},getVerticalMargin:function(){return a},hasMargin:function(){return r},insertElementBefore:function(){return B},parsePixelValue:function(){return o},removeAttribute:function(){return g},removeElement:function(){return C},removeEventListenerFromElement:function(){return x},selectAllElements:function(){return b},selectElement:function(){return y},setAttribute:function(){return f},setAttributes:function(){return m}});const s=t=>{const e=t.getBoundingClientRect(),n=getComputedStyle(t),i={top:parseFloat(n.marginTop),right:parseFloat(n.marginRight),bottom:parseFloat(n.marginBottom),left:parseFloat(n.marginLeft)};return{x:e.left,y:e.top,width:e.width,height:e.height,right:e.right,bottom:e.bottom,margins:i}},c=(t,e=!1)=>({shouldIncludeInLayout(){return e},getBounds(){const e=t.getBoundingClientRect(),n=window.getComputedStyle(t),i={top:o(n.marginTop),right:o(n.marginRight),bottom:o(n.marginBottom),left:o(n.marginLeft)},r={x:e.left,y:e.top,width:e.width,height:e.height,right:e.right,bottom:e.bottom,margins:i};return{element:r,inner:{x:r.x,y:r.y,width:r.width,height:r.height,right:r.right,bottom:r.bottom},outer:{x:r.x-i.left,y:r.y-i.top,width:r.width+i.left+i.right,height:r.height+i.top+i.bottom,right:r.right+i.right,bottom:r.bottom+i.bottom}}}}),l=1e-6;class d extends Error{constructor(t){super(t),this.name="BoundaryCalculationError"}}class h{static validateNumber(t,e){if(!Number.isFinite(t))throw new d(`${e} must be a finite number`);if(Math.abs(t)>1e7)throw new d(`${e} exceeds maximum safe coordinate value`)}static validateRectangle(t,e="Rectangle"){if(this.validateNumber(t.x,`${e}.x`),this.validateNumber(t.y,`${e}.y`),this.validateNumber(t.width,`${e}.width`),this.validateNumber(t.height,`${e}.height`),this.validateNumber(t.right,`${e}.right`),this.validateNumber(t.bottom,`${e}.bottom`),t.width<0||t.height<0)throw new d(`${e} cannot have negative dimensions`);const n=t.x+t.width,i=t.y+t.height;if(Math.abs(n-t.right)>l||Math.abs(i-t.bottom)>l)throw new d(`${e} coordinates are inconsistent with dimensions`)}static validateMargins(t){if(t.top<0||t.right<0||t.bottom<0||t.left<0)throw new d("Margins cannot be negative")}static validateScale(t){if(t.x<=0||t.y<=0)throw new d("Scale factors must be positive")}static calculateBounds(t,e,n={}){this.validateRectangle(t,"elementBounds"),this.validateMargins(t.margins);const{offset:i={x:0,y:0},scale:o={x:1,y:1}}=n;this.validateNumber(i.x,"offset.x"),this.validateNumber(i.y,"offset.y"),this.validateScale(o);const r=this.createBaseBounds(t,i,o),u=this.calculateCombinedChildBounds(e),a=this.combineBounds(r,u,t.margins);return this.validateRectangle(a.inner,"combinedBounds.inner"),this.validateRectangle(a.outer,"combinedBounds.outer"),a}static createBaseBounds(t,e,n){const i=t.width*n.x,o=t.height*n.y,r={x:e.x,y:e.y,width:i,height:o,right:e.x+i,bottom:e.y+o},u={x:t.x,y:t.y,width:t.width,height:t.height,right:t.x+t.width,bottom:t.y+t.height};return{element:{...t},inner:u,outer:r}}static calculateCombinedChildBounds(t){const e=t.filter((t=>{try{return t.shouldIncludeInLayout()}catch(t){return console.warn("Error checking child view layout inclusion:",t),!1}}));if(0===e.length)return null;let n=!1,i=this.createEmptyBounds();for(const t of e)try{const e=t.getBounds();try{this.validateRectangle(e.inner,"childBounds.inner"),this.validateRectangle(e.outer,"childBounds.outer"),i=this.expandBoundary(i,e.inner),i=this.expandBoundary(i,e.outer),n=!0}catch(t){console.warn("Invalid child view bounds:",t)}}catch(t){console.warn("Error getting child view bounds:",t)}return n?this.calculateDimensions(i):null}static createEmptyBounds(){return{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY,width:0,height:0,right:Number.NEGATIVE_INFINITY,bottom:Number.NEGATIVE_INFINITY}}static expandBoundary(t,e){return{x:Math.min(t.x,e.x),y:Math.min(t.y,e.y),right:Math.max(t.right,e.right),bottom:Math.max(t.bottom,e.bottom),width:0,height:0}}static combineBounds(t,e,n){const i={element:{...t.element},inner:{...t.inner},outer:{...t.outer}};return e&&(i.inner=h.expandBoundary(i.inner,e),i.inner=h.calculateDimensions(i.inner),i.outer=h.expandBoundary(i.outer,e),i.outer=h.calculateDimensions(i.outer)),i.outer=h.applyMargins(i.outer,n),i}static applyMargins(t,e){const n=t.x-e.left,i=t.y-e.top,o=t.right+e.right,r=t.bottom+e.bottom;return{x:n,y:i,width:o-n,height:r-i,right:o,bottom:r}}static calculateDimensions(t){const e=Math.max(0,t.right-t.x),n=Math.max(0,t.bottom-t.y);return{x:t.x,y:t.y,width:e,height:n,right:t.x+e,bottom:t.y+n}}}function m(t,e,n=!1){Object.entries(e).forEach((([e,i])=>{f(t,e,i,n)}))}function f(t,e,n,i=!1){if("className"===e)t.className.baseVal=n;else if("style"===e&&"object"==typeof n)Object.assign(t.style,n);else if(e.startsWith("on")&&"function"==typeof n){const i=e.substring(2).toLowerCase();t.addEventListener(i,n)}else e in t?t[e]=n:i?t.setAttributeNS(null,e,n):t.setAttribute(e,n)}function g(t,e){if("className"===e)t.className="";else if("style"===e)t.removeAttribute("style");else if(e.startsWith("on")){const t=e.substring(2).toLowerCase();console.warn(`Cannot remove event listener for ${t}. You need to keep a reference to the handler.`)}else t.removeAttribute(e)}function y(t,e=document){return"undefined"==typeof document?null:e.querySelector(t)}function b(t,e=document){return e.querySelectorAll(t)}function p(t,e,n){if("undefined"==typeof document)return null;const i=document.createElement(t);return e&&m(i,e),n&&n.length>0&&n.forEach((t=>{"string"==typeof t?i.appendChild(document.createTextNode(t)):i.appendChild(t)})),i}function w(t,e,n){if("undefined"==typeof document)return null;const i=document.createElementNS("http://www.w3.org/2000/svg",t);return e&&m(i,e,!0),n&&n.length>0&&n.forEach((t=>{"string"==typeof t?i.appendChild(document.createTextNode(t)):i.appendChild(t)})),i}function v(t,e,n){"undefined"!=typeof document&&t.addEventListener(e,n)}function x(t,e,n){"undefined"!=typeof document&&t.removeEventListener(e,n)}function E(t,e){return"undefined"==typeof document||("string"==typeof e?t.appendChild(document.createTextNode(e)):t.appendChild(e)),t}function B(t,e,n){"undefined"!=typeof document&&t.insertBefore(e,n)}function N(t){if("undefined"!=typeof document)for(;t.firstChild;)t.removeChild(t.firstChild)}function C(t){"undefined"!=typeof document&&t.parentElement&&t.parentElement.removeChild(t)}module.exports=e}();