import{parsePixelValue}from"./utilities";export const GetElementBounds=t=>{const e=t.getBoundingClientRect(),i=getComputedStyle(t),o={top:parseFloat(i.marginTop),right:parseFloat(i.marginRight),bottom:parseFloat(i.marginBottom),left:parseFloat(i.marginLeft)};return{x:e.left,y:e.top,width:e.width,height:e.height,right:e.right,bottom:e.bottom,margins:o}};export const ChildViewElement=(t,e=!1)=>({shouldIncludeInLayout(){return e},getBounds(){const e=t.getBoundingClientRect(),i=window.getComputedStyle(t),o={top:parsePixelValue(i.marginTop),right:parsePixelValue(i.marginRight),bottom:parsePixelValue(i.marginBottom),left:parsePixelValue(i.marginLeft)},r={x:e.left,y:e.top,width:e.width,height:e.height,right:e.right,bottom:e.bottom,margins:o};return{element:r,inner:{x:r.x,y:r.y,width:r.width,height:r.height,right:r.right,bottom:r.bottom},outer:{x:r.x-o.left,y:r.y-o.top,width:r.width+o.left+o.right,height:r.height+o.top+o.bottom,right:r.right+o.right,bottom:r.bottom+o.bottom}}}});const EPSILON=1e-6,MAX_SAFE_COORDINATE=1e7;export class BoundaryCalculationError extends Error{constructor(t){super(t),this.name="BoundaryCalculationError"}}export class ViewBoundaryCalculator{static validateNumber(t,e){if(!Number.isFinite(t))throw new BoundaryCalculationError(`${e} must be a finite number`);if(Math.abs(t)>1e7)throw new BoundaryCalculationError(`${e} exceeds maximum safe coordinate value`)}static validateRectangle(t,e="Rectangle"){if(this.validateNumber(t.x,`${e}.x`),this.validateNumber(t.y,`${e}.y`),this.validateNumber(t.width,`${e}.width`),this.validateNumber(t.height,`${e}.height`),this.validateNumber(t.right,`${e}.right`),this.validateNumber(t.bottom,`${e}.bottom`),t.width<0||t.height<0)throw new BoundaryCalculationError(`${e} cannot have negative dimensions`);const i=t.x+t.width,o=t.y+t.height;if(Math.abs(i-t.right)>EPSILON||Math.abs(o-t.bottom)>EPSILON)throw new BoundaryCalculationError(`${e} coordinates are inconsistent with dimensions`)}static validateMargins(t){if(t.top<0||t.right<0||t.bottom<0||t.left<0)throw new BoundaryCalculationError("Margins cannot be negative")}static validateScale(t){if(t.x<=0||t.y<=0)throw new BoundaryCalculationError("Scale factors must be positive")}static calculateBounds(t,e,i={}){this.validateRectangle(t,"elementBounds"),this.validateMargins(t.margins);const{offset:o={x:0,y:0},scale:r={x:1,y:1}}=i;this.validateNumber(o.x,"offset.x"),this.validateNumber(o.y,"offset.y"),this.validateScale(r);const a=this.createBaseBounds(t,o,r),n=this.calculateCombinedChildBounds(e),h=this.combineBounds(a,n,t.margins);return this.validateRectangle(h.inner,"combinedBounds.inner"),this.validateRectangle(h.outer,"combinedBounds.outer"),h}static createBaseBounds(t,e,i){const o=t.width*i.x,r=t.height*i.y,a={x:e.x,y:e.y,width:o,height:r,right:e.x+o,bottom:e.y+r},n={x:t.x,y:t.y,width:t.width,height:t.height,right:t.x+t.width,bottom:t.y+t.height};return{element:{...t},inner:n,outer:a}}static calculateCombinedChildBounds(t){const e=t.filter((t=>{try{return t.shouldIncludeInLayout()}catch(t){return console.warn("Error checking child view layout inclusion:",t),!1}}));if(0===e.length)return null;let i=!1,o=this.createEmptyBounds();for(const t of e)try{const e=t.getBounds();try{this.validateRectangle(e.inner,"childBounds.inner"),this.validateRectangle(e.outer,"childBounds.outer"),o=this.expandBoundary(o,e.inner),o=this.expandBoundary(o,e.outer),i=!0}catch(t){console.warn("Invalid child view bounds:",t)}}catch(t){console.warn("Error getting child view bounds:",t)}return i?this.calculateDimensions(o):null}static createEmptyBounds(){return{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY,width:0,height:0,right:Number.NEGATIVE_INFINITY,bottom:Number.NEGATIVE_INFINITY}}static expandBoundary(t,e){return{x:Math.min(t.x,e.x),y:Math.min(t.y,e.y),right:Math.max(t.right,e.right),bottom:Math.max(t.bottom,e.bottom),width:0,height:0}}static combineBounds(t,e,i){const o={element:{...t.element},inner:{...t.inner},outer:{...t.outer}};return e&&(o.inner=ViewBoundaryCalculator.expandBoundary(o.inner,e),o.inner=ViewBoundaryCalculator.calculateDimensions(o.inner),o.outer=ViewBoundaryCalculator.expandBoundary(o.outer,e),o.outer=ViewBoundaryCalculator.calculateDimensions(o.outer)),o.outer=ViewBoundaryCalculator.applyMargins(o.outer,i),o}static applyMargins(t,e){const i=t.x-e.left,o=t.y-e.top,r=t.right+e.right,a=t.bottom+e.bottom;return{x:i,y:o,width:r-i,height:a-o,right:r,bottom:a}}static calculateDimensions(t){const e=Math.max(0,t.right-t.x),i=Math.max(0,t.bottom-t.y);return{x:t.x,y:t.y,width:e,height:i,right:t.x+e,bottom:t.y+i}}}