import{debounce}from"@avati/debounce";import{throttle}from"@avati/throttle";const _listeners=Symbol("listeners"),_weakRefMap=Symbol("weakRefMap"),_handleWeakRef=Symbol("handleWeakRef"),_validateParams=Symbol("validateParams"),_generateEventId=Symbol("generateEventId"),_eventIdCounter=Symbol("eventIdCounter");class EventListenerManager{constructor(){this.EVENT_MAPPINGS={debounce:new Set(["input","change","keyup","keydown","focus","blur","click"]),throttle:new Set(["mousemove","scroll","resize","wheel"])},this[_listeners]=new Map,this[_weakRefMap]=new WeakMap,this[_eventIdCounter]=0,this.add=this.add.bind(this),this.remove=this.remove.bind(this),this.defaultOptions=Object.freeze({capture:!1,passive:!0,once:!1,async:!1})}[_validateParams](e,t,n){if(!(e instanceof Element||e instanceof Window||e instanceof global.Document))throw new TypeError("Element must be an instance of Element, Window, or Document");if("string"!=typeof t)throw new TypeError("Event type must be a string");if("function"!=typeof n)throw new TypeError("Callback must be a function")}[_generateEventId](){return"event_"+ ++this[_eventIdCounter]}[_handleWeakRef](e,t){let n=this[_weakRefMap].get(e);n||(n=new Set,this[_weakRefMap].set(e,n)),n.add(t)}recommendation(e,t){const n="throttle"===t?"debounce":"throttle";this.EVENT_MAPPINGS[n].has(e)&&console.warn(`Event type '${e}' is recommended to be ${n}d instead of ${t}d.`)}add(e,t,n,r={}){this[_validateParams](e,t,n);const o=this[_generateEventId](),a={...this.defaultOptions,...r};let i=n;if(a.debounce&&a.throttle)throw new Error("Cannot specify both debounce and throttle options");if(a.async){i=async e=>{try{await n(e)}catch(e){if(!(a.onError&&e instanceof Error))throw e;a.onError(e)}}}a.debounce?(this.recommendation(t,"debounce"),i=debounce(i,{wait:a.debounce,leading:a.leading,trailing:a.trailing,debug:a.debug,onError:a.onError})):a.throttle&&(this.recommendation(t,"throttle"),i=throttle(i,a.throttle,{leading:a.leading,trailing:a.trailing,onError:a.onError}));const s=async t=>{a.metadata&&(t.metadata={timestamp:Date.now(),eventId:o,originalCallback:n.name||"anonymous"});try{await i.call(e,t)}catch(e){if(!(a.onError&&e instanceof Error))throw e;a.onError(e)}a.once&&this.remove(o)},l={element:new WeakRef(e),eventType:t,callback:s,originalCallback:n,options:a,timestamp:Date.now()};return this[_listeners].set(o,l),this[_handleWeakRef](e,o),e.addEventListener(t,s,a),o}remove(e){const t=this[_listeners].get(e);if(!t)return!1;const n=t.element.deref();if(n){n.removeEventListener(t.eventType,t.callback,t.options);const r=this[_weakRefMap].get(n);r&&(r.delete(e),0===r.size&&this[_weakRefMap].delete(n))}return this[_listeners].delete(e),!0}addWithCleanup(e,t,n,r={}){const o=this.add(e,t,n,r);return()=>this.remove(o)}getListeners(e){const t=this[_weakRefMap].get(e);return t?Array.from(t).map((t=>{const n=this[_listeners].get(t);if(!n)return null;const r=n.element.deref();return r&&r===e?{eventId:t,eventType:n.eventType,options:n.options,timestamp:n.timestamp}:null})).filter((e=>null!==e)):[]}removeAll(e){const t=this[_weakRefMap].get(e);if(t){for(const e of t)this.remove(e);this[_weakRefMap].delete(e)}}once(e,t,n,r={}){return this.add(e,t,n,{...r,once:!0})}}const eventManager=new EventListenerManager;export default eventManager;