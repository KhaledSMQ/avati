/*!
 * @avatijs/signal 0.1.1
 * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://avati.io/ for details.
 */var t={d:(s,i)=>{for(var e in i)t.o(i,e)&&!t.o(s,e)&&Object.defineProperty(s,e,{enumerable:!0,get:i[e]})},o:(t,s)=>Object.prototype.hasOwnProperty.call(t,s)},s={};t.d(s,{fB:()=>o,Yz:()=>r,IH:()=>m,Vp:()=>S,Hp:()=>g,Bs:()=>l,bb:()=>w});class i{constructor(){this.queue=new Set,this.processing=!1,this.updateDepth=0,this.maxUpdateDepth=1e3}static getInstance(){return this.instance||(this.instance=new i),this.instance}schedule(t){if(this.updateDepth>=this.maxUpdateDepth)throw Error("Maximum update depth exceeded - possible circular dependency");this.queue.add(t),this.processing||this.processQueue()}processQueue(){this.processing=!0,this.updateDepth++;try{for(;this.queue.size>0;){const t=Array.from(this.queue);this.queue.clear(),t.sort(((t,s)=>t.getDepth()-s.getDepth()));for(const s of t)s.isDirty()&&!s.isDisposed()&&s.recompute()}}finally{this.processing=!1,this.updateDepth--}}}class e{constructor(t){this.dirty=!0,this.disposed=!1,this.dependencies=new Set,this.dependents=new Set,this.depth=0,this.name=t}addDependency(t){this.dependencies.has(t)||(this.dependencies.add(t),"ComputedSignal"==t.constructor.name&&this.updateDepth())}removeDependency(t){this.dependencies.delete(t)&&this.updateDepth()}dispose(){this.disposed||(this.disposed=!0,this.clearDependencies(),this.dependents.clear())}isDirty(){return this.dirty}isDisposed(){return this.disposed}getDepth(){return this.depth}markDirty(){this.disposed||(this.dirty=!0,i.getInstance().schedule(this))}hasSignal(t){return this.dependencies.has(t)}clearDependencies(){for(const t of this.dependencies)t.removeDependent(this);this.dependencies.clear(),this.updateDepth()}updateDepth(){const t=this.depth;let s=0;for(const t of this.dependencies)"ComputedSignal"==t.constructor.name&&(s=Math.max(s,t.getDepth()+1));if(t!==s){this.depth=s;for(const t of this.dependents)t.updateDepth()}}}class n{constructor(){this.computationStack=[],this.batchDepth=0,this.batchQueue=new Set,this.activeEffects=new Set}static getInstance(){return this.instance||(this.instance=new n),this.instance}getCurrentComputation(){return this.computationStack[this.computationStack.length-1]}pushComputation(t){t&&this.computationStack.includes(t)||this.computationStack.push(t)}popComputation(){this.computationStack.pop()}isBatching(){return this.batchDepth>0}beginBatch(){this.batchDepth++}endBatch(){this.batchDepth--,0===this.batchDepth&&this.flushBatchQueue()}addToBatchQueue(t){this.batchQueue.add(t)}flushBatchQueue(){const t=new Set(this.batchQueue);this.batchQueue.clear();const s=new Set;for(const i of t)for(const t of i.getDependents())s.add(t);for(const t of s)t.markDirty()}setCurrentComputation(t){this.computationStack[this.computationStack.length-1]=t}registerEffect(t){this.activeEffects.add(t)}unregisterEffect(t){this.activeEffects.delete(t)}isInEffect(){return this.activeEffects.size>0}}class h{constructor(t,s){this.disposed=!1,this.computation=new class extends e{constructor(t,i){super(s),this.effect=t,this.fn=i}recompute(){if(this.disposed)return;const t=n.getInstance();t.pushComputation(this);try{t.pushComputation(this),t.registerEffect(this.effect),this.effect.runEffect()}finally{t.unregisterEffect(this.effect),t.popComputation(),this.dirty=!1}}}(this,t),this.computation.recompute()}dispose(){if(!this.disposed){if(this.disposed=!0,this.cleanup)try{this.cleanup()}catch(t){}this.computation.dispose()}}runEffect(){if(!this.disposed){if(this.cleanup)try{this.cleanup()}catch(t){}try{this.cleanup=this.computation.fn()}catch(t){throw t}}}}function r(t,s){return function(t,s){new h((()=>{}),s)}(0,"debug-"+s),t}class o{static trackUpdate(t){this.metrics.updates++,this.updateTimes.push(t),this.updateTimes.length>100&&this.updateTimes.shift(),this.metrics.averageUpdateTime=this.updateTimes.reduce(((t,s)=>t+s),0)/this.updateTimes.length}static trackComputation(t){this.metrics.computations++,this.metrics.maxChainDepth=Math.max(this.metrics.maxChainDepth,t)}static getMetrics(){return{...this.metrics}}static reset(){this.metrics={updates:0,computations:0,maxChainDepth:0,averageUpdateTime:0},this.updateTimes=[]}}o.metrics={updates:0,computations:0,maxChainDepth:0,averageUpdateTime:0},o.updateTimes=[];class c extends Error{constructor(t){super(`Cannot ${t} a disposed signal`),this.name="SignalDisposedError"}}class a extends Error{constructor(t){super("Circular dependency detected"+(t?` in signal "${t}"`:"")),this.name="CircularDependencyError"}}class u{constructor(t,s={}){var i;this.dependents=new Set,this.disposed=!1,this.t=t,this.equals=null!==(i=s.equals)&&void 0!==i?i:Object.is,this.name=s.name||"anonymous"}isCommutable(){throw Error("Method not implemented.")}get value(){if(this.disposed)throw new c("read from");return this.trackDependency(),this.t}set value(t){if(this.disposed)throw new c("write to");this.equals(this.t,t)||(this.t=t,this.notifyDependents())}get_value_bypass_tracking(){if(this.disposed)throw new c("read from");return this.t}update(t){this.value=t(this.t)}addDependent(t){this.dependents.add(t)}removeDependent(t){this.dependents.delete(t)}notifyDependents(){const t=n.getInstance();if(t.isBatching())t.addToBatchQueue(this);else for(const t of this.dependents)t.markDirty()}dispose(){var t;if(this.disposed)return;this.disposed=!0;const s=new Set(this.dependents);this.dependents.clear();for(const i of s)"ComputedSignal"==i.constructor.name||"ComputedSignal"==(null===(t=i.signal)||void 0===t?void 0:t.constructor.name)?("ComputedSignal"==i.constructor.name?i:i.signal).dispose():i.dispose()}isDisposed(){return this.disposed}getDependents(){return this.dependents||new Set}hasDependents(){return this.dependents.size>0}toString(){return`Signal(${this.name})`}trackDependency(){const t=n.getInstance().getCurrentComputation();t&&(t.addDependency(this),this.addDependent(t))}}class d extends e{constructor(t){super("subscription"),this.callback=t}recompute(){if(this.disposed)return;const t=n.getInstance(),s=t.getCurrentComputation();t.setCurrentComputation(this);try{this.callback()}finally{s&&t.setCurrentComputation(s),this.dirty=!1}}}class f extends u{constructor(t,s={}){super(t,s)}subscribe(t){if(this.disposed)throw new c("subscribe to");const s=new d((()=>t(this.value)));return s.recompute(),()=>s.dispose()}}class p extends f{constructor(t,s={}){super({},s),this.computeFn=t,this.computation=new class extends e{constructor(t){super(),this.signal=t}recompute(){if(this.disposed)return;const t=n.getInstance(),s=t.getCurrentComputation();if(t.setCurrentComputation(this),t.isInEffect())throw new a("Cannot create computed signal that depends on effects");try{for(const t of this.dependencies)if(t.isDisposed())throw this.signal.dispose(),new c("read from disposed dependency");const t=this.signal.computeFn();this.signal.equals(this.signal.t,t)||(this.signal.t=t,this.signal.notifyDependents())}catch(t){throw t instanceof c&&this.signal.dispose(),t}finally{s&&t.setCurrentComputation(s),this.dirty=!1}}}(this),this.computation.recompute()}get value(){if(this.disposed)throw new c("read from");const t=this.computation.dependencies;for(const s of t)if(s.isDisposed())throw this.dispose(),new c("read from disposed dependency");return this.computation.isDirty()&&this.computation.recompute(),this.trackDependency(),this.t}set value(t){throw Error("Cannot set the value of a computed signal")}getDepth(){return this.computation.getDepth()}dispose(){if(!this.disposed){super.dispose(),this.computation.dispose();for(const t of this.dependents)(t instanceof p||t.signal instanceof p)&&(t instanceof p?t:t.signal).dispose()}}}function l(){n.instance=void 0,i.instance=void 0,o.reset()}const w=t=>JSON.stringify({value:t.value,name:t.name,disposed:t.disposed});function g(t){return t instanceof f}function m(t){return t instanceof p?t.getDepth():0}function S(t){const s=new Set,i=new Set;return function t(e){var n;if(i.has(e))return!0;if(s.has(e))return!1;s.add(e),i.add(e);const h=e.dependents||new Set;for(const s of h)if((null===(n=s.computation)||void 0===n?void 0:n.signal)&&t(s.computation.signal))return!0;return i.delete(e),!1}(t)}var y=s.fB,v=s.Yz,D=s.IH,C=s.Vp,b=s.Hp,x=s.Bs,E=s.bb;export{y as SignalMonitor,v as debug,D as getSignalDepth,C as hasCircularDependency,b as isSignal,x as resetSignalSystem,E as serializeSignal};
//# sourceMappingURL=index.js.map