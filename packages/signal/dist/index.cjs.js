!function(){"use strict";var e={d:function(t,n){for(var s in n)e.o(n,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:n[s]})},o:function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r:function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{AsyncSignal:function(){return P},CircularDependencyError:function(){return a},Computation:function(){return r},ComputedSignal:function(){return c},EffectImpl:function(){return g},LocalStorageProvider:function(){return O},MemoryStorageProvider:function(){return M},QueueSignal:function(){return F},SessionStorageProvider:function(){return Q},Signal:function(){return u},SignalContext:function(){return n},SignalDisposedError:function(){return o},SignalMonitor:function(){return p},UpdateQueue:function(){return i},asyncSignal:function(){return U},batch:function(){return s},combine:function(){return h},computed:function(){return d},createQueueSignal:function(){return $},createSignal:function(){return l},debounced:function(){return w},debug:function(){return D},defaultEquals:function(){return b},effect:function(){return v},filtered:function(){return y},getSignalDepth:function(){return E},hasCircularDependency:function(){return k},isSignal:function(){return I},map:function(){return m},peek:function(){return S},persisted:function(){return B},resetSignalSystem:function(){return x},serializeSignal:function(){return q},threshold:function(){return C},throttled:function(){return _},validated:function(){return f},withHistory:function(){return T}});class n{static instance;computationStack=[];batchDepth=0;batchQueue=new Set;activeEffects=new Set;static getInstance(){return this.instance||(this.instance=new n),this.instance}getCurrentComputation(){return this.computationStack[this.computationStack.length-1]}pushComputation(e){e&&this.computationStack.includes(e)||this.computationStack.push(e)}popComputation(){this.computationStack.pop()}isBatching(){return this.batchDepth>0}beginBatch(){this.batchDepth++}endBatch(){this.batchDepth--,0===this.batchDepth&&this.flushBatchQueue()}addToBatchQueue(e){this.batchQueue.add(e)}flushBatchQueue(){const e=new Set(this.batchQueue);this.batchQueue.clear();const t=new Set;for(const n of e)for(const e of n.getDependents())t.add(e);for(const e of t)e.markDirty()}setCurrentComputation(e){this.computationStack[this.computationStack.length-1]=e}registerEffect(e){this.activeEffects.add(e)}unregisterEffect(e){this.activeEffects.delete(e)}isInEffect(){return this.activeEffects.size>0}}function s(e){const t=n.getInstance();t.beginBatch();try{return e()}finally{t.endBatch()}}class i{static instance;queue=new Set;processing=!1;updateDepth=0;maxUpdateDepth=1e3;static getInstance(){return this.instance||(this.instance=new i),this.instance}schedule(e){if(this.updateDepth>=this.maxUpdateDepth)throw new Error("Maximum update depth exceeded - possible circular dependency");this.queue.add(e),this.processing||this.processQueue()}processQueue(){this.processing=!0,this.updateDepth++;try{for(;this.queue.size>0;){const e=Array.from(this.queue);this.queue.clear(),e.sort(((e,t)=>e.getDepth()-t.getDepth()));for(const t of e)t.isDirty()&&!t.isDisposed()&&t.recompute()}}finally{this.processing=!1,this.updateDepth--}}}class r{dirty=!0;disposed=!1;dependencies=new Set;dependents=new Set;depth=0;name;constructor(e){this.name=e}addDependency(e){this.dependencies.has(e)||(this.dependencies.add(e),e instanceof c&&this.updateDepth())}removeDependency(e){this.dependencies.delete(e)&&this.updateDepth()}dispose(){this.disposed||(this.disposed=!0,this.clearDependencies(),this.dependents.clear())}isDirty(){return this.dirty}isDisposed(){return this.disposed}getDepth(){return this.depth}markDirty(){this.disposed||(this.dirty=!0,i.getInstance().schedule(this))}clearDependencies(){for(const e of this.dependencies)e.removeDependent(this);this.dependencies.clear(),this.updateDepth()}updateDepth(){const e=this.depth;let t=0;for(const e of this.dependencies)e instanceof c&&(t=Math.max(t,e.getDepth()+1));if(e!==t){this.depth=t;for(const e of this.dependents)e.updateDepth()}}hasSignal(e){return this.dependencies.has(e)}}class o extends Error{constructor(e){super(`Cannot ${e} a disposed signal`),this.name="SignalDisposedError"}}class a extends Error{constructor(e){super("Circular dependency detected"+(e?` in signal "${e}"`:"")),this.name="CircularDependencyError"}}class u{equals;_value;dependents=new Set;disposed=!1;name;constructor(e,t={}){this._value=e,this.equals=t.equals??Object.is,this.name=t.name||"anonymous"}get value(){if(this.disposed)throw new o("read from");return this.trackDependency(),this._value}set value(e){if(this.disposed)throw new o("write to");this.equals(this._value,e)||(this._value=e,this.notifyDependents())}get_value_bypass_tracking(){if(this.disposed)throw new o("read from");return this._value}update(e){this.value=e(this._value)}subscribe(e){if(this.disposed)throw new o("subscribe to");const t=new c((()=>e(this.value)));return()=>t.dispose()}trackDependency(){const e=n.getInstance().getCurrentComputation();e&&(e.addDependency(this),this.addDependent(e))}addDependent(e){this.dependents.add(e)}removeDependent(e){this.dependents.delete(e)}notifyDependents(){const e=n.getInstance();if(e.isBatching())e.addToBatchQueue(this);else for(const e of this.dependents)e.markDirty()}dispose(){if(this.disposed)return;this.disposed=!0;const e=new Set(this.dependents);this.dependents.clear();for(const t of e)if(t instanceof c||t.signal instanceof c){(t instanceof c?t:t.signal).dispose()}else t.dispose()}isDisposed(){return this.disposed}getDependents(){return this.dependents||new Set}hasDependents(){return this.dependents.size>0}toString(){return`Signal(${this.name})`}}class c extends u{computation;computeFn;constructor(e,t={}){super(void 0,t),this.computeFn=e,this.computation=new class extends r{signal;constructor(e){super(e.name),this.signal=e}recompute(){if(this.disposed)return;const e=n.getInstance(),t=e.getCurrentComputation();if(e.setCurrentComputation(this),e.isInEffect())throw new a("Cannot create computed signal that depends on effects");try{for(const e of this.dependencies)if(e.isDisposed())throw this.signal.dispose(),new o("read from disposed dependency");const e=this.signal.computeFn();this.signal.equals(this.signal._value,e)||(this.signal._value=e,this.signal.notifyDependents())}catch(e){throw e instanceof o&&this.signal.dispose(),e}finally{t&&e.setCurrentComputation(t),this.dirty=!1}}}(this),this.computation.recompute()}get value(){if(this.disposed)throw new o("read from");const e=this.computation.dependencies;for(const t of e)if(t.isDisposed())throw this.dispose(),new o("read from disposed dependency");return this.computation.isDirty()&&this.computation.recompute(),this.trackDependency(),this._value}set value(e){throw new Error("Cannot set the value of a computed signal")}getDepth(){return this.computation.getDepth()}dispose(){if(!this.disposed){super.dispose(),this.computation.dispose();for(const e of this.dependents)if(e instanceof c||e.signal instanceof c){(e instanceof c?e:e.signal).dispose()}}}}function d(e,t){return new c(e,t)}function h(e,t){return d((()=>e.map((e=>e.value))),{equals:t?.equals??((e,t)=>!(!e||!t||e.length!==t.length)&&e.every(((e,n)=>Object.is(e,t[n])))),name:t?.name||`Signal(combine)[${e.map((e=>e.toString())).join(", ")}]`})}class p{static metrics={updates:0,computations:0,maxChainDepth:0,averageUpdateTime:0};static updateTimes=[];static trackUpdate(e){this.metrics.updates++,this.updateTimes.push(e),this.updateTimes.length>100&&this.updateTimes.shift(),this.metrics.averageUpdateTime=this.updateTimes.reduce(((e,t)=>e+t),0)/this.updateTimes.length}static trackComputation(e){this.metrics.computations++,this.metrics.maxChainDepth=Math.max(this.metrics.maxChainDepth,e)}static getMetrics(){return{...this.metrics}}static reset(){this.metrics={updates:0,computations:0,maxChainDepth:0,averageUpdateTime:0},this.updateTimes=[]}}function l(e,t){return new u(e,t)}function f(e,t,n){const s=l(e,n),i=d((()=>{const e=t(s.value);return"string"==typeof e?e:e?null:"Validation failed"}));return new Proxy(s,{get(e,t){if("value"===t){const t=i.value;if(t)throw new Error(t);return e.value}return e[t]},set(e,n,s){if("value"===n){const n=t(s);if("string"==typeof n)throw new Error(n);if(!n)throw new Error("Validation failed");e.value=s}return!0}})}function m(e,t,n){return d((()=>t(e.value)),n)}class g{computation;cleanup;disposed=!1;constructor(e,t){this.computation=new class extends r{effect;fn;constructor(e,n){super(t),this.effect=e,this.fn=n}recompute(){if(this.disposed)return;const e=n.getInstance();e.pushComputation(this);try{e.pushComputation(this),e.registerEffect(this.effect),this.effect.runEffect()}finally{e.unregisterEffect(this.effect),e.popComputation(),this.dirty=!1}}}(this,e),this.computation.recompute()}runEffect(){if(!this.disposed){if(this.cleanup)try{this.cleanup()}catch(e){console.error("Error in effect cleanup:",e)}try{this.cleanup=this.computation.fn()}catch(e){throw console.error("Error in effect:",e),e}}}dispose(){if(!this.disposed){if(this.disposed=!0,this.cleanup)try{this.cleanup()}catch(e){console.error("Error in effect cleanup:",e)}this.computation.dispose()}}}function v(e,t){return new g(e,t)}function w(e,t,n){const s=l(e.value,n);let i;return v((()=>{const n=e.value;return i&&clearTimeout(i),i=setTimeout((()=>{s.value=n}),t),()=>{i&&clearTimeout(i)}})),s}function y(e,t,n){const s=l(e.value,n);return v((()=>{const n=e.value;t(n)&&(s.value=n)})),s}function D(e,t){return v((()=>{console.log(`[Signal Debug] ${t}:`,e.value)}),`debug-${t}`),e}function S(e){const t=n.getInstance(),s=t.getCurrentComputation();t.setCurrentComputation(void 0);try{return e.get_value_bypass_tracking()}finally{s&&t.setCurrentComputation(s)}}function C(e,t,n){return d((()=>{const n=e.value,s=S(e);return Math.abs(n-s)>=t?n:s}),{...n,equals:(e,n)=>Math.abs(e-n)<t})}const b=(e,t)=>Object.is(e,t),q=e=>JSON.stringify({value:e.value,name:e.name,disposed:e.disposed});function I(e){return e instanceof u}function E(e){return e instanceof c?e.getDepth():0}function k(e){const t=new Set,n=new Set;return function e(s){if(n.has(s))return!0;if(t.has(s))return!1;t.add(s),n.add(s);const i=s.dependents||new Set;for(const t of i)if(t.computation?.signal&&e(t.computation.signal))return!0;return n.delete(s),!1}(e)}function x(){n.instance=void 0,i.instance=void 0,p.reset()}function T(e,t=10,n){const i=n?.equals??b,r=l(e,{...n,equals:i}),o=l([e]),a=l(0),u=d((()=>a.value>0)),c=d((()=>a.value<o.value.length-1)),h=Object.create(r);return h.history=o,h.canUndo=u,h.canRedo=c,Object.defineProperty(h,"value",{get:()=>r.value,set:e=>{i(r.value,e)||s((()=>{const n=a.value+1,s=o.value.slice(0,n).concat([e]);s.length>t?(s.shift(),a.value=n-1):a.value=n,o.value=s,r.value=e}))}}),h.undo=()=>{u.value&&s((()=>{a.value--,r.value=o.value[a.value]}))},h.redo=()=>{c.value&&s((()=>{a.value++,r.value=o.value[a.value]}))},h}function _(e,t,n){const s=l(e.value,n);let i,r=0;return v((()=>{const n=e.value,o=Date.now();return o-r>=t?(s.value=n,r=o):i||(i=setTimeout((()=>{s.value=n,r=Date.now(),i=void 0}),t-(o-r))),()=>{i&&clearTimeout(i)}})),s}class O{getItem(e){if("undefined"==typeof window)return null;const t=window.localStorage.getItem(e);return t?JSON.parse(t):null}setItem(e,t){"undefined"!=typeof window&&window.localStorage.setItem(e,JSON.stringify(t))}removeItem(e){"undefined"!=typeof window&&window.localStorage.removeItem(e)}}class Q{getItem(e){if("undefined"==typeof window)return null;const t=window.sessionStorage.getItem(e);return t?JSON.parse(t):null}setItem(e,t){"undefined"!=typeof window&&window.sessionStorage.setItem(e,JSON.stringify(t))}removeItem(e){"undefined"!=typeof window&&window.sessionStorage.removeItem(e)}}class M{store=new Map;getItem(e){return this.store.get(e)??null}setItem(e,t){this.store.set(e,t)}removeItem(e){this.store.delete(e)}}class j extends u{storage;key;disposed=!1;constructor(e,t,n,s){super(n.getItem(e)??t,s),this.key=e,this.storage=n,v((()=>{this.disposed||this.storage.setItem(this.key,this.value)}),`persist-${e}`)}get value(){if(this.disposed)throw new o("Cannot read from disposed signal");return super.value}set value(e){if(this.disposed)throw new o("Cannot write to disposed signal");super.value=e}update(e){if(this.disposed)throw new o("Cannot update disposed signal");this.value=e(this.value)}dispose(){this.disposed||(this.disposed=!0,this.storage.removeItem(this.key),super.dispose())}reload(){if(this.disposed)throw new o("Cannot reload disposed signal");const e=this.storage.getItem(this.key);null!==e&&(this.value=e)}clear(){if(this.disposed)throw new o("Cannot clear disposed signal");this.storage.removeItem(this.key)}isDisposed(){return this.disposed}}function B(e,t,n,s){return new j(e,t,n,s)}class P extends u{fetchFn;options;abortController=null;constructor(e,t={}){super({data:null,loading:!1,error:null,timestamp:0},t),this.fetchFn=e,this.options=t}async fetch(e=!1){if(this.isCacheValid()&&!e)return this.value.data;this.abortController&&this.abortController.abort(),this.abortController=new AbortController,this.value={...this.value,loading:!0,error:null};let t=0;const n=this.options.retryConfig?.attempts||1,s=this.options.retryConfig?.delay||1e3,i=this.options.retryConfig?.backoffFactor||2;for(;t<n;)try{const e=await this.fetchFn();return this.value={data:e,loading:!1,error:null,timestamp:Date.now()},this.options.onSuccess?.(e),e}catch(e){if(t++,t===n)return this.value={...this.value,loading:!1,error:e},this.options.onError?.(e),null;await new Promise((e=>setTimeout(e,s*Math.pow(i,t-1))))}return null}isCacheValid(){if(!this.options.cache?.enabled)return!1;if(!this.value.data)return!1;const e=this.options.cache.ttl||3e5;return Date.now()-this.value.timestamp<e}refresh(){return this.fetch(!0)}dispose(){this.abortController&&this.abortController.abort(),super.dispose()}}function U(e,t){return new P(e,t)}class F{queue;constructor(){this.queue=l([])}enqueue(e,t=0){const n=Math.random().toString(36).substring(2),s={id:n,data:e,priority:t,timestamp:Date.now()};return this.queue.value=[...this.queue.value,s].sort(((e,t)=>t.priority-e.priority||e.timestamp-t.timestamp)),n}dequeue(){if(this.isEmpty())return;const[e,...t]=this.queue.value;return this.queue.value=t,e?.data}peek(){return this.queue.value[0]?.data}remove(e){const t=this.queue.value.length;return this.queue.value=this.queue.value.filter((t=>t.id!==e)),t!==this.queue.value.length}clear(){this.queue.value=[]}isEmpty(){return 0===this.queue.value.length}size(){return this.queue.value.length}getQueue(){return this.queue}}function $(){return new F}module.exports=t}();