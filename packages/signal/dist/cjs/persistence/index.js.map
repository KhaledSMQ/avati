{"version":3,"file":"persistence/index.js","mappings":"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","sources":["webpack://@avatijs/signal/webpack/bootstrap","webpack://@avatijs/signal/webpack/runtime/define property getters","webpack://@avatijs/signal/webpack/runtime/hasOwnProperty shorthand","webpack://@avatijs/signal/webpack/runtime/make namespace object","webpack://@avatijs/signal/./src/core/errors.ts","webpack://@avatijs/signal/./src/core/context.ts","webpack://@avatijs/signal/./src/core/base.ts","webpack://@avatijs/signal/./src/core/updateQueue.ts","webpack://@avatijs/signal/./src/core/computation.ts","webpack://@avatijs/signal/./src/core/SubscriptionComputation.ts","webpack://@avatijs/signal/./src/core/signal.ts","webpack://@avatijs/signal/./src/core/effect.ts","webpack://@avatijs/signal/./src/persistence/persisted.ts","webpack://@avatijs/signal/./src/core/utility.ts","webpack://@avatijs/signal/./src/core/createSignal.ts","webpack://@avatijs/signal/./src/core/computedSignal.ts","webpack://@avatijs/signal/./src/core/computed.ts","webpack://@avatijs/signal/./src/core/batch.ts","webpack://@avatijs/signal/./src/persistence/withHistory.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Disposed signal operations\n */\nexport class SignalDisposedError extends Error {\n    constructor(operation: string) {\n        super(`Cannot ${operation} a disposed signal`);\n        this.name = 'SignalDisposedError';\n    }\n}\n\n/**\n * Circular dependency detection\n */\nexport class CircularDependencyError extends Error {\n    constructor(signalName?: string) {\n        super(`Circular dependency detected${signalName ? ` in signal \"${signalName}\"` : ''}`);\n        this.name = 'CircularDependencyError';\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, IEffect, WritableSignal } from './interfaces';\n\n/**\n * Manages the global state and context of signal computations\n */\nexport class Context {\n    private static instance: Context;\n    private computationStack: IComputation[] = [];\n    private batchDepth = 0;\n    private batchQueue = new Set<WritableSignal<any>>();\n    private activeEffects = new Set<Disposable>();\n\n    static getInstance(): Context {\n        if (!this.instance) {\n            this.instance = new Context();\n        }\n        return this.instance;\n    }\n\n    getCurrentComputation(): IComputation | undefined {\n        return this.computationStack[this.computationStack.length - 1];\n    }\n\n    pushComputation(computation: IComputation): void {\n        // Check for circular dependencies\n        if (computation && this.computationStack.includes(computation)) {\n            // throw new CircularDependencyError();\n            return;\n        }\n        // we can push undefined to the stack\n        this.computationStack.push(computation);\n    }\n\n    popComputation(): void {\n        this.computationStack.pop();\n    }\n\n    isBatching(): boolean {\n        return this.batchDepth > 0;\n    }\n\n    beginBatch(): void {\n        this.batchDepth++;\n    }\n\n    endBatch(): void {\n        this.batchDepth--;\n        if (this.batchDepth === 0) {\n            this.flushBatchQueue();\n        }\n    }\n\n    addToBatchQueue(signal: WritableSignal<any>): void {\n        this.batchQueue.add(signal);\n    }\n\n    flushBatchQueue(): void {\n        // Create a new Set for unique signals\n        const uniqueSignals = new Set(this.batchQueue);\n        this.batchQueue.clear();\n\n        // Get all dependent computations\n        const computations = new Set<IComputation>();\n\n        for (const signal of uniqueSignals) {\n            for (const dependent of signal.getDependents()) {\n                computations.add(dependent);\n            }\n        }\n        // Mark all computations as dirty\n        for (const computation of computations) {\n            computation.markDirty();\n        }\n    }\n\n    setCurrentComputation(computation: IComputation): void {\n        this.computationStack[this.computationStack.length - 1] = computation;\n    }\n\n\n    registerEffect(effect: IEffect): void {\n        this.activeEffects.add(effect);\n    }\n\n    unregisterEffect(effect: IEffect): void {\n        this.activeEffects.delete(effect);\n    }\n\n    // Add this method to check if we're currently in an effect\n    isInEffect(): boolean {\n        return this.activeEffects.size > 0;\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation, SignalOptions, WritableSignal } from './interfaces';\nimport { SignalDisposedError } from './errors';\nimport { EqualityFunction, TransformFunction } from './types';\nimport { Context } from './context';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Base<T> implements WritableSignal<T> {\n    /**\n     * Function to compare previous and next values for equality.\n     * Used to determine if dependents should be notified of changes.\n     */\n    equals: EqualityFunction<T>;\n    /**\n     * Optional name for debugging and identification purposes\n     */\n    name?: string;\n    /**\n     * Set of computations that depend on this signal's value\n     */\n    protected dependents = new Set<IComputation>();\n\n    /**\n     * Flag indicating whether this signal has been disposed\n     */\n    protected disposed = false;\n\n    /**\n     * Creates a new Signal instance\n     *\n     * @param initialValue - The initial value of the signal\n     * @param options - Configuration options for the signal\n     */\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        this._value = initialValue as T;\n        // Use provided equals function or default to Object.is\n        this.equals = options.equals ?? Object.is;\n        this.name = options.name || 'anonymous';\n    }\n\n    isCommutable(): boolean {\n        throw new Error('Method not implemented.');\n    }\n\n    /**\n     * The current value stored in the signal\n     */\n    protected _value: T;\n\n    /**\n     * Gets the current value of the signal.\n     * Tracks dependencies and throws if the signal is disposed.\n     */\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Sets a new value for the signal.\n     * Only updates and notifies dependents if the new value is different from the current value.\n     *\n     * @param newValue - The new value to set\n     */\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('write to');\n        }\n        if (!this.equals(this._value, newValue)) {\n            this._value = newValue;\n            this.notifyDependents();\n        }\n    }\n\n    /**\n     * Gets the current value of the signal without tracking dependencies.\n     */\n    get_value_bypass_tracking(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n        return this._value;\n    }\n\n    /**\n     * Updates the signal's value using a transformation function\n     *\n     * @param fn - Function that takes the current value and returns a new value\n     */\n    update(fn: TransformFunction<T>): void {\n        this.value = fn(this._value);\n    }\n\n\n    /**\n     * Adds a computation as dependent on this signal\n     *\n     * @param computation - The computation to add as a dependent\n     */\n    addDependent(computation: IComputation): void {\n        this.dependents.add(computation);\n    }\n\n    /**\n     * Removes a computation from this signal's dependents\n     *\n     * @param computation - The computation to remove\n     */\n    removeDependent(computation: IComputation): void {\n        this.dependents.delete(computation);\n    }\n\n    /**\n     * Notifies all dependent computations of a value change\n     * Handles batching through SignalContext if active\n     */\n    notifyDependents(): void {\n        const context = Context.getInstance();\n\n        if (context.isBatching()) {\n            context.addToBatchQueue(this);\n            return;\n        }\n\n        for (const dependent of this.dependents) {\n            dependent.markDirty();\n        }\n    }\n\n    /**\n     * Disposes of the signal and its dependent computations\n     * Prevents memory leaks by cleaning up all references\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n\n        // Create a copy of dependents before iterating to avoid modification during iteration\n        const dependentsToDispose = new Set(this.dependents);\n\n        // First, clear own dependents\n        this.dependents.clear();\n\n        // Then dispose all dependent computations\n        for (const dependent of dependentsToDispose) {\n            // @ts-ignore TODO use concrete type\n            if (dependent.constructor.name == 'ComputedSignal'  || dependent['signal']?.constructor.name == 'ComputedSignal') {\n                // If the dependent is or belongs to a ComputedSignal, dispose it\n                // @ts-ignore\n                const signal = dependent.constructor.name == 'ComputedSignal' ? dependent : dependent['signal'];\n                signal.dispose();\n            } else {\n                // For other types of computations, just dispose the computation\n                dependent.dispose();\n            }\n        }\n    }\n\n    /**\n     * Returns whether the signal has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    getDependents(): Set<IComputation> {\n        return this.dependents || new Set();\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    hasDependents(): boolean {\n        return this.dependents.size > 0;\n    }\n\n    toString(): string {\n        return `Signal(${this.name})`;\n    }\n\n    /**\n     * Tracks the current computation as dependent on this signal\n     */\n    protected trackDependency(): void {\n        const computation = Context.getInstance().getCurrentComputation();\n        if (computation) {\n            computation.addDependency(this);\n            this.addDependent(computation);\n        }\n    }\n}\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation } from './interfaces';\n\n/**\n * Manages the scheduling and processing of signal updates\n * Uses a topological sort to handle updates in the correct order\n */\nexport class UpdateQueue {\n    private static instance: UpdateQueue;\n    private queue = new Set<IComputation>();\n    private processing = false;\n    private updateDepth = 0;\n    private maxUpdateDepth = 1000; // Configurable maximum update depth\n\n    static getInstance(): UpdateQueue {\n        if (!this.instance) {\n            this.instance = new UpdateQueue();\n        }\n        return this.instance;\n    }\n\n    /**\n     * Schedule a computation for update\n     */\n    schedule(computation: IComputation): void {\n        if (this.updateDepth >= this.maxUpdateDepth) {\n            throw new Error('Maximum update depth exceeded - possible circular dependency');\n        }\n\n        this.queue.add(computation);\n        if (!this.processing) {\n            this.processQueue();\n        }\n    }\n\n    /**\n     * Process all scheduled updates in dependency order\n     */\n    private processQueue(): void {\n        this.processing = true;\n        this.updateDepth++;\n\n        try {\n            while (this.queue.size > 0) {\n                const computations = Array.from(this.queue);\n                this.queue.clear();\n\n                // Sort by dependency depth to ensure correct update order\n                computations.sort((a, b) => a.getDepth() - b.getDepth());\n\n                for (const computation of computations) {\n                    if (computation.isDirty() && !computation.isDisposed()) {\n                        computation.recompute();\n                    }\n                }\n            }\n        } finally {\n            this.processing = false;\n            this.updateDepth--;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, type WritableSignal } from './interfaces';\nimport { UpdateQueue } from './updateQueue';\n\n/**\n * Base class for managing reactive computations\n */\nexport abstract class Computation implements Disposable, IComputation {\n    protected dirty = true;\n    protected disposed = false;\n    protected dependencies = new Set<WritableSignal<any>>();\n    protected dependents = new Set<Computation>();\n    protected depth = 0;\n    protected name?: string;\n\n    abstract recompute(): void;\n\n    constructor(name?: string) {\n        this.name = name;\n    }\n\n\n    /**\n     * Add a dependency to this computation\n     */\n    addDependency(signal: WritableSignal<any>): void {\n        if (!this.dependencies.has(signal)) {\n            this.dependencies.add(signal);\n            if (signal.constructor.name == 'ComputedSignal') {\n                this.updateDepth();\n            }\n        }\n    }\n\n    /**\n     * Remove a dependency from this computation\n     */\n    removeDependency(signal: WritableSignal<any>): void {\n        if (this.dependencies.delete(signal)) {\n            this.updateDepth();\n        }\n    }\n\n    /**\n     * Clean up computation resources\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        this.clearDependencies();\n        this.dependents.clear();\n    }\n\n    /**\n     * Check if computation is dirty\n     */\n    isDirty(): boolean {\n        return this.dirty;\n    }\n\n    /**\n     * Check if computation has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Add a dependent computation, which will be recomputed when this computation updates\n     */\n    getDepth(): number {\n        return this.depth;\n    }\n\n    /**\n     * Mark computation as dirty and schedule update\n     */\n    markDirty(): void {\n\n        if (!this.disposed) {\n            this.dirty = true;\n            UpdateQueue.getInstance().schedule(this);\n        }\n    }\n\n    /**\n     * Check if signal is a dependency of this computation\n     * @param signal\n     */\n    hasSignal(signal: WritableSignal<any>): boolean {\n        return this.dependencies.has(signal);\n    }\n\n    /**\n     * Clear all dependencies and update depth\n     */\n    clearDependencies(): void {\n        for (const dep of this.dependencies) {\n            dep.removeDependent(this);\n        }\n        this.dependencies.clear();\n        this.updateDepth();\n    }\n\n    /**\n     * Update the computation's depth in the dependency graph\n     */\n    updateDepth(): void {\n        const oldDepth = this.depth;\n        let maxDepth = 0;\n\n        for (const dep of this.dependencies) {\n            if (dep.constructor.name == 'ComputedSignal') {\n                // @ts-ignore TODO use concrete type\n                maxDepth = Math.max(maxDepth, dep.getDepth() + 1);\n            }\n        }\n\n        if (oldDepth !== maxDepth) {\n            this.depth = maxDepth;\n            // Propagate depth update to dependents\n            for (const dependent of this.dependents) {\n                dependent.updateDepth();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Context } from './context';\nimport { Computation } from './computation';\n\nexport class SubscriptionComputation extends Computation {\n    constructor(\n        private callback: () => void\n    ) {\n        super('subscription');\n    }\n\n    recompute(): void {\n        if (this.disposed) return;\n        const context = Context.getInstance();\n        const prevComputation = context.getCurrentComputation();\n        context.setCurrentComputation(this);\n\n        try {\n            this.callback();\n        } finally {\n            if (prevComputation) {\n                context.setCurrentComputation(prevComputation);\n            }\n            this.dirty = false;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Core imports for the Signal implementation\n */\nimport { SignalOptions } from './interfaces';\nimport { UnsubscribeFunction } from './types';\nimport { Base } from './base';\nimport { SignalDisposedError } from './errors';\nimport { SubscriptionComputation } from './SubscriptionComputation';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Signal<T> extends Base<T> {\n\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        super(initialValue, options);\n    }\n\n    /**\n     * Creates a subscription to the signal's value changes\n     *\n     * @param callback - Function to call when the value changes\n     * @returns Function to unsubscribe from changes\n     */\n    subscribe(callback: (value: T) => void): UnsubscribeFunction {\n        if (this.disposed) {\n            throw new SignalDisposedError('subscribe to');\n        }\n        const computed = new SubscriptionComputation(() => {\n            return callback(this.value);\n        });\n\n        computed.recompute();\n\n        return () => computed.dispose();\n    }\n }\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Disposable, IEffect } from './interfaces';\nimport { Computation } from './computation';\nimport { Context } from './context';\nimport { Cleanup, EffectFunction } from './types';\n\n\n/**\n * Implementation of reactive effects that automatically track and respond to signal changes.\n * Effects are used to perform side effects in response to reactive updates.\n *\n * @example\n * // Basic effect usage\n * const count = new Signal(0);\n * const dispose = effect(() => {\n *   console.log(`Count changed to: ${count.value}`);\n * });\n * count.value = 1; // Logs: \"Count changed to: 1\"\n * dispose(); // Cleanup effect\n *\n * @example\n * // Effect with cleanup\n * const visible = new Signal(true);\n * const dispose = effect(() => {\n *   if (visible.value) {\n *     const element = document.createElement('div');\n *     document.body.appendChild(element);\n *     // Return cleanup function\n *     return () => {\n *       document.body.removeChild(element);\n *     };\n *   }\n * });\n *\n * @example\n * // Named effect for debugging\n * const timer = new Signal(0);\n * const dispose = effect(() => {\n *   console.log(`Timer: ${timer.value}`);\n * }, 'timerLogger');\n *\n * @example\n * // Effect with multiple dependencies\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n * const dispose = effect(() => {\n *   console.log(`Name changed to: ${firstName.value} ${lastName.value}`);\n * });\n *\n * @example\n * // Effect with error handling\n * const data = new Signal<string | Error>(null);\n * const dispose = effect(() => {\n *   try {\n *     if (data.value instanceof Error) {\n *       console.error('Error:', data.value);\n *     } else {\n *       console.log('Data:', data.value);\n *     }\n *   } catch (error) {\n *     console.error('Effect error:', error);\n *   }\n * });\n */\nexport class EffectImpl implements IEffect {\n    /**\n     * The computation that tracks dependencies and handles recomputation\n     */\n    private readonly computation: Computation;\n\n    /**\n     * Cleanup function from the previous effect execution\n     */\n    cleanup: Cleanup | undefined;\n\n    /**\n     * Flag indicating whether the effect has been disposed\n     */\n    disposed = false;\n\n    /**\n     * Creates a new effect instance\n     *\n     * @param fn - The effect function that may return a cleanup function\n     * @param name - Optional name for debugging purposes\n     */\n    constructor(fn: EffectFunction, name?: string) {\n        this.computation = new class EffectIm extends Computation {\n            // @ts-ignore\n            constructor(private effect: EffectImpl, private fn: EffectFunction) {\n                super(name);\n            }\n\n            /**\n             * Recomputes the effect when dependencies change\n             * Handles proper context management and error boundaries\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = Context.getInstance();\n                context.pushComputation(this);\n\n                try {\n                    context.pushComputation(this);\n                    context.registerEffect(this.effect);\n                    this.effect.runEffect();\n                } finally {\n                    context.unregisterEffect(this.effect);\n                    context.popComputation();\n                    this.dirty = false;\n                }\n            }\n        }(this, fn);\n\n        // Initial computation\n        this.computation.recompute();\n    }\n\n    /**\n     * Disposes of the effect, running cleanup and preventing further executions\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        if (this.cleanup) {\n            try {\n                this.cleanup();\n            } catch (error) {\n                console.error('Error in effect cleanup:', error);\n            }\n        }\n        this.computation.dispose();\n    }\n\n    /**\n     * Executes the effect function and manages cleanup\n     * Handles error boundaries for both effect and cleanup execution\n     */\n    runEffect(): void {\n        if (this.disposed) return;\n\n        // Run cleanup from previous execution\n        if (this.cleanup) {\n            try {\n                this.cleanup();\n            } catch (error) {\n                console.error('Error in effect cleanup:', error);\n            }\n        }\n\n        try {\n            // @ts-ignore - We know this exists from the constructor\n            this.cleanup = this.computation['fn']();\n        } catch (error) {\n            console.error('Error in effect:', error);\n            throw error;\n        }\n    }\n}\n\n/**\n * Creates a new effect that automatically tracks and responds to signal changes\n *\n * @param fn - Effect function that may return a cleanup function\n * @param name - Optional name for debugging purposes\n * @returns A disposable object to cleanup the effect\n *\n * @example\n * // DOM manipulation effect\n * const isVisible = new Signal(true);\n * const dispose = effect(() => {\n *   const element = document.querySelector('.target');\n *   element.style.display = isVisible.value ? 'block' : 'none';\n * });\n *\n * @example\n * // Effect with async operations\n * const userId = new Signal<number | null>(null);\n * const dispose = effect(() => {\n *   const id = userId.value;\n *   if (id !== null) {\n *     let cancelled = false;\n *     fetchUserData(id).then(data => {\n *       if (!cancelled) {\n *         // Handle data\n *       }\n *     });\n *     return () => {\n *       cancelled = true;\n *     };\n *   }\n * });\n */\nexport function effect(fn: EffectFunction, name?: string): Disposable {\n    return new EffectImpl(fn, name);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { effect, Signal, SignalDisposedError, SignalOptions } from '../core';\n\n/**\n * Interface for storage providers to get, set and remove persisted values\n */\nexport interface StorageProvider<T> {\n    /** Retrieves value by key, returns null if not found */\n    getItem(key: string): T | null;\n\n    /** Stores value with given key */\n    setItem(key: string, value: T): void;\n\n    /** Removes value with given key */\n    removeItem(key: string): void;\n}\n\n/**\n * Uses browser localStorage for persistent storage across sessions\n * Falls back gracefully when not in browser environment\n */\nexport class LocalStorageProvider<T> implements StorageProvider<T> {\n    /**\n     * Gets item from localStorage\n     * @param key - Key to retrieve\n     * @returns Stored value or null if not found/not in browser\n     */\n    getItem(key: string): T | null {\n        if (typeof window === 'undefined') return null;\n        const presented = window.localStorage.getItem(key);\n        if (presented) {\n            return JSON.parse(presented);\n        }\n        return null;\n    }\n\n    /**\n     * Sets item in localStorage\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    setItem(key: string, value: T): void {\n        if (typeof window === 'undefined') return;\n        window.localStorage.setItem(key, JSON.stringify(value));\n    }\n\n    /**\n     * Removes item from localStorage\n     * @param key - Key to remove\n     */\n    removeItem(key: string): void {\n        if (typeof window === 'undefined') return;\n        window.localStorage.removeItem(key);\n    }\n}\n\n/**\n * Uses browser sessionStorage for temporary storage during session\n * Falls back gracefully when not in browser environment\n */\nexport class SessionStorageProvider<T> implements StorageProvider<T> {\n    /**\n     * Gets item from sessionStorage\n     * @param key - Key to retrieve\n     * @returns Stored value or null if not found/not in browser\n     */\n    getItem(key: string): T | null {\n        if (typeof window === 'undefined') return null;\n        const presented = window.sessionStorage.getItem(key);\n        if (presented) {\n            return JSON.parse(presented);\n        }\n        return null;\n    }\n\n    /**\n     * Sets item in sessionStorage\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    setItem(key: string, value: T): void {\n        if (typeof window === 'undefined') return;\n        window.sessionStorage.setItem(key, JSON.stringify(value));\n    }\n\n    /**\n     * Removes item from sessionStorage\n     * @param key - Key to remove\n     */\n    removeItem(key: string): void {\n        if (typeof window === 'undefined') return;\n        window.sessionStorage.removeItem(key);\n    }\n}\n\n/**\n * In-memory storage provider for testing and SSR environments\n * Data persists only during runtime\n */\nexport class MemoryStorageProvider<T> implements StorageProvider<T> {\n    /** Map to store key-value pairs in memory */\n    private store = new Map<string, T>();\n\n    /**\n     * Gets item from memory store\n     * @param key - Key to retrieve\n     * @returns Stored value or null if not found\n     */\n    getItem(key: string): T | null {\n        return this.store.get(key) ?? null;\n    }\n\n    /**\n     * Sets item in memory store\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    setItem(key: string, value: T): void {\n        this.store.set(key, value);\n    }\n\n    /**\n     * Removes item from memory store\n     * @param key - Key to remove\n     */\n    removeItem(key: string): void {\n        this.store.delete(key);\n    }\n}\n\n\nexport type PersistedSignalStorage<T> = {\n    storage?: StorageProvider<T>;\n}\n\nexport type PersistedSignalSignalOptions<T> = SignalOptions<T> & PersistedSignalStorage<T>;\n\nexport class Persisted<T> extends Signal<T> {\n    disposed = false;\n    private readonly storage: StorageProvider<T>;\n    private readonly key: string;\n\n    constructor(\n        key: string,\n        initialValue: T,\n        storage: StorageProvider<T>,\n        options?: SignalOptions<T>,\n    ) {\n        const storedValue = storage.getItem(key);\n        super(storedValue ?? initialValue, options);\n\n        this.key = key;\n        this.storage = storage;\n\n        effect(() => {\n            if (this.disposed) return;\n            this.storage.setItem(this.key, this.value);\n        }, `persist-${key}`);\n    }\n\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot read from disposed signal');\n        }\n        return super.value;\n    }\n\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot write to disposed signal');\n        }\n        super.value = newValue;\n    }\n\n    update(fn: (current: T) => T): void {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot update disposed signal');\n        }\n        this.value = fn(this.value);\n    }\n\n    dispose(): void {\n        if (this.disposed) return;\n        this.disposed = true;\n        this.storage.removeItem(this.key);\n        super.dispose();\n    }\n\n    reload(): void {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot reload disposed signal');\n        }\n        const value = this.storage.getItem(this.key);\n        if (value !== null) {\n            this.value = value;\n        }\n    }\n\n    clear(): void {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot clear disposed signal');\n        }\n        this.storage.removeItem(this.key);\n    }\n\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n}\n\nexport function persisted<T>(\n    key: string,\n    initialValue: T,\n    storage: StorageProvider<T>,\n    options?: SignalOptions<T>,\n): Persisted<T> {\n    return new Persisted(key, initialValue, storage, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n/**\n * Default equality function for comparing signal values\n * Uses Object.is for strict equality comparison\n */\nexport const defaultEquals = <T>(a: T, b: T): boolean => Object.is(a, b);\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport type { SignalOptions } from './interfaces';\n\n/**\n * Create a new writable signal\n */\nexport function createSignal<T>(\n    initialValue: T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new Signal(initialValue, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\nimport { Computation } from './computation';\nimport { Context } from './context';\nimport { Signal } from './signal';\nimport type { SignalOptions, WritableSignal } from './interfaces';\nimport { CircularDependencyError, SignalDisposedError } from './errors';\n\n/**\n * Signal that derives its value from other signals\n *\n * @example\n * // Create base signals\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n * // Create a computed signal that depends on firstName and lastName\n * const fullName = new ComputedSignal(() => {\n *   return `${firstName.value} ${lastName.value}`;\n * });\n *\n * console.log(fullName.value); // Output: \"John Doe\"\n *\n * // When a dependency changes, the computed value updates automatically\n * firstName.value = 'Jane';\n * console.log(fullName.value); // Output: \"Jane Doe\"\n */\nexport class ComputedSignal<T> extends Signal<T> {\n\n    /** Internal computation instance to manage dependencies and recomputation */\n    private readonly computation: Computation;\n\n    /** Function that computes the derived value */\n    private computeFn: () => T;\n\n    /**\n     * Creates a new computed signal\n     * @param compute Function that derives the signal value\n     * @param options Configuration options for the signal\n     */\n    constructor(compute: () => T, options: SignalOptions<T> = {}) {\n        super({} as T, options);\n        this.computeFn = compute;\n\n        // Create an anonymous computation class instance\n        this.computation = new class ComputationA extends Computation {\n            constructor(private signal: ComputedSignal<T>) {\n                super();\n            }\n\n            /**\n             * Recomputes the signal value when dependencies change\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = Context.getInstance();\n                const prevComputation = context.getCurrentComputation();\n                context.setCurrentComputation(this);\n\n                // Prevent circular dependencies through effects\n                if (context.isInEffect()) {\n                    throw new CircularDependencyError(\n                        `Cannot create computed signal that depends on effects`,\n                    );\n                }\n\n                try {\n                    // Check if any dependencies have been disposed\n                    for (const dep of this.dependencies) {\n                        if (dep.isDisposed()) {\n                            this.signal.dispose();\n                            throw new SignalDisposedError('read from disposed dependency');\n                        }\n                    }\n\n                    // Compute new value and update if changed\n                    const newValue = this.signal.computeFn();\n                    if (!this.signal.equals(this.signal._value, newValue)) {\n                        this.signal._value = newValue;\n                        this.signal.notifyDependents();\n                    }\n                } catch (error) {\n                    // Handle disposal errors\n                    if (error instanceof SignalDisposedError) {\n                        this.signal.dispose();\n                    }\n                    throw error;\n                } finally {\n                    // Restore previous computation context\n                    if (prevComputation) {\n                        context.setCurrentComputation(prevComputation);\n                    }\n                    this.dirty = false;\n                }\n            }\n        }(this);\n        // Initial computation\n        this.computation.recompute();\n\n    }\n\n    /**\n     * Gets the current value of the computed signal\n     */\n    override get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        // Verify dependencies are still valid\n        const dependencies = this.computation['dependencies'] as Set<WritableSignal<any>>;\n        for (const dep of dependencies) {\n            if (dep.isDisposed()) {\n                this.dispose();\n                throw new SignalDisposedError('read from disposed dependency');\n            }\n        }\n\n        // Recompute if dependencies have changed\n        if (this.computation.isDirty()) {\n            this.computation.recompute();\n        }\n\n        // Track this signal as a dependency for other computations\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Computed signals cannot be set directly\n     */\n    override set value(_: T) {\n        throw new Error('Cannot set the value of a computed signal');\n    }\n\n    /**\n     * Gets the depth of this signal in the dependency graph\n     */\n    getDepth(): number {\n        return this.computation.getDepth();\n    }\n\n    /**\n     * Cleans up the signal and its dependencies\n     */\n    override dispose(): void {\n        if (this.disposed) return;\n\n        super.dispose();\n        this.computation.dispose();\n\n        // Recursively dispose dependent computed signals\n        for (const dependent of this.dependents) {\n            // @ts-ignore\n            if (dependent instanceof ComputedSignal || dependent['signal'] instanceof ComputedSignal) {\n                // @ts-ignore\n                const signal = dependent instanceof ComputedSignal ? dependent : dependent['signal'];\n                signal.dispose();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport { ComputedSignal } from './computedSignal';\nimport type { SignalOptions } from './interfaces';\n\n\n\n/**\n * Create a computed signal that derives its value from other signals\n */\nexport function computed<T>(\n    compute: () => T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new ComputedSignal(compute, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Context } from './context';\n\n/**\n * Batch multiple signal updates to prevent cascading updates\n */\nexport function batch<T>(fn: () => T): T {\n    const context = Context.getInstance();\n    context.beginBatch();\n    try {\n        return fn();\n    } finally {\n        context.endBatch();\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { batch, computed, createSignal, defaultEquals, Signal, SignalOptions } from '../core';\n\n/**\n * Adds undo/redo functionality to a Signal by wrapping it with history tracking\n *\n * @param initialValue Initial value for the signal\n * @param maxHistory Maximum number of history states to maintain\n * @param options Signal configuration options\n * @returns Enhanced signal with undo/redo capabilities and history access\n */\nexport function withHistory<T>(\n    initialValue: T,\n    maxHistory: number = 10,\n    options?: SignalOptions<T>,\n): Signal<T> & {\n    undo(): void;\n    redo(): void;\n    history: Signal<T[]>;\n    canUndo: Signal<boolean>;\n    canRedo: Signal<boolean>;\n} {\n    // Use provided equals function or default\n    const equalsFn = options?.equals ?? defaultEquals;\n\n    const signal = createSignal(initialValue, {\n        ...options,\n        equals: equalsFn, // Ensure equals function is properly passed\n    });\n    const history = createSignal<T[]>([initialValue]);\n    const currentIndex = createSignal(0);\n\n    const canUndo = computed(() => currentIndex.value > 0);\n    const canRedo = computed(() => currentIndex.value < history.value.length - 1);\n\n    const wrapper = Object.create(signal) as Signal<T> & {\n        undo(): void;\n        redo(): void;\n        history: Signal<T[]>;\n        canUndo: Signal<boolean>;\n        canRedo: Signal<boolean>;\n    };\n\n    wrapper.history = history;\n    wrapper.canUndo = canUndo;\n    wrapper.canRedo = canRedo;\n\n    // Use batch for atomic updates\n    Object.defineProperty(wrapper, 'value', {\n        get: () => signal.value,\n        set: (newValue: T) => {\n            if (!equalsFn(signal.value, newValue)) {\n                batch(() => {\n                    const newIndex = currentIndex.value + 1;\n                    const newHistory = history.value\n                        .slice(0, newIndex)\n                        .concat([newValue]);\n\n                    if (newHistory.length > maxHistory) {\n                        newHistory.shift();\n                        currentIndex.value = newIndex - 1;\n                    } else {\n                        currentIndex.value = newIndex;\n                    }\n\n                    history.value = newHistory;\n                    signal.value = newValue;\n                });\n            }\n        },\n    });\n\n    wrapper.undo = () => {\n        if (canUndo.value) {\n            batch(() => {\n                currentIndex.value--;\n                signal.value = history.value[currentIndex.value] as T;\n            });\n        }\n    };\n\n    wrapper.redo = () => {\n        if (canRedo.value) {\n            batch(() => {\n                currentIndex.value++;\n                signal.value = history.value[currentIndex.value] as T;\n            });\n        }\n    };\n\n    return wrapper;\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","SignalDisposedError","Error","constructor","operation","super","this","name","CircularDependencyError","signalName","Context","computationStack","batchDepth","batchQueue","Set","activeEffects","getInstance","instance","getCurrentComputation","length","pushComputation","computation","includes","push","popComputation","pop","isBatching","beginBatch","endBatch","flushBatchQueue","addToBatchQueue","signal","add","uniqueSignals","clear","computations","dependent","getDependents","markDirty","setCurrentComputation","registerEffect","effect","unregisterEffect","delete","isInEffect","size","Base","initialValue","options","dependents","disposed","_value","equals","is","isCommutable","trackDependency","newValue","notifyDependents","get_value_bypass_tracking","update","fn","addDependent","removeDependent","context","dispose","dependentsToDispose","isDisposed","hasDependents","toString","addDependency","UpdateQueue","queue","processing","updateDepth","maxUpdateDepth","schedule","processQueue","Array","from","sort","a","b","getDepth","isDirty","recompute","Computation","dirty","dependencies","depth","has","removeDependency","clearDependencies","hasSignal","dep","oldDepth","maxDepth","Math","max","SubscriptionComputation","callback","prevComputation","Signal","subscribe","computed","EffectImpl","runEffect","cleanup","error","LocalStorageProvider","getItem","window","presented","localStorage","JSON","parse","setItem","stringify","removeItem","SessionStorageProvider","sessionStorage","MemoryStorageProvider","store","Map","set","Persisted","storage","storedValue","reload","persisted","defaultEquals","createSignal","ComputedSignal","compute","computeFn","_","batch","withHistory","maxHistory","equalsFn","history","currentIndex","canUndo","canRedo","wrapper","create","newIndex","newHistory","slice","concat","shift","undo","redo"],"sourceRoot":""}