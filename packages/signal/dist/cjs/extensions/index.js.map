{"version":3,"file":"extensions/index.js","mappings":"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","sources":["webpack://@avatijs/signal/webpack/bootstrap","webpack://@avatijs/signal/webpack/runtime/define property getters","webpack://@avatijs/signal/webpack/runtime/hasOwnProperty shorthand","webpack://@avatijs/signal/webpack/runtime/make namespace object","webpack://@avatijs/signal/./src/core/context.ts","webpack://@avatijs/signal/./src/core/batch.ts","webpack://@avatijs/signal/./src/core/errors.ts","webpack://@avatijs/signal/./src/core/base.ts","webpack://@avatijs/signal/./src/core/updateQueue.ts","webpack://@avatijs/signal/./src/core/computation.ts","webpack://@avatijs/signal/./src/core/SubscriptionComputation.ts","webpack://@avatijs/signal/./src/core/signal.ts","webpack://@avatijs/signal/./src/core/createSignal.ts","webpack://@avatijs/signal/./src/core/effect.ts","webpack://@avatijs/signal/./src/extensions/debounced.ts","webpack://@avatijs/signal/./src/extensions/filtered.ts","webpack://@avatijs/signal/./src/core/computedSignal.ts","webpack://@avatijs/signal/./src/core/computed.ts","webpack://@avatijs/signal/./src/extensions/map.ts","webpack://@avatijs/signal/./src/extensions/peek.ts","webpack://@avatijs/signal/./src/extensions/queue.ts","webpack://@avatijs/signal/./src/extensions/throttled.ts","webpack://@avatijs/signal/./src/extensions/threshold.ts","webpack://@avatijs/signal/./src/extensions/validated.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, IEffect, WritableSignal } from './interfaces';\n\n/**\n * Manages the global state and context of signal computations\n */\nexport class Context {\n    private static instance: Context;\n    private computationStack: IComputation[] = [];\n    private batchDepth = 0;\n    private batchQueue = new Set<WritableSignal<any>>();\n    private activeEffects = new Set<Disposable>();\n\n    static getInstance(): Context {\n        if (!this.instance) {\n            this.instance = new Context();\n        }\n        return this.instance;\n    }\n\n    getCurrentComputation(): IComputation | undefined {\n        return this.computationStack[this.computationStack.length - 1];\n    }\n\n    pushComputation(computation: IComputation): void {\n        // Check for circular dependencies\n        if (computation && this.computationStack.includes(computation)) {\n            // throw new CircularDependencyError();\n            return;\n        }\n        // we can push undefined to the stack\n        this.computationStack.push(computation);\n    }\n\n    popComputation(): void {\n        this.computationStack.pop();\n    }\n\n    isBatching(): boolean {\n        return this.batchDepth > 0;\n    }\n\n    beginBatch(): void {\n        this.batchDepth++;\n    }\n\n    endBatch(): void {\n        this.batchDepth--;\n        if (this.batchDepth === 0) {\n            this.flushBatchQueue();\n        }\n    }\n\n    addToBatchQueue(signal: WritableSignal<any>): void {\n        this.batchQueue.add(signal);\n    }\n\n    flushBatchQueue(): void {\n        // Create a new Set for unique signals\n        const uniqueSignals = new Set(this.batchQueue);\n        this.batchQueue.clear();\n\n        // Get all dependent computations\n        const computations = new Set<IComputation>();\n\n        for (const signal of uniqueSignals) {\n            for (const dependent of signal.getDependents()) {\n                computations.add(dependent);\n            }\n        }\n        // Mark all computations as dirty\n        for (const computation of computations) {\n            computation.markDirty();\n        }\n    }\n\n    setCurrentComputation(computation: IComputation): void {\n        this.computationStack[this.computationStack.length - 1] = computation;\n    }\n\n\n    registerEffect(effect: IEffect): void {\n        this.activeEffects.add(effect);\n    }\n\n    unregisterEffect(effect: IEffect): void {\n        this.activeEffects.delete(effect);\n    }\n\n    // Add this method to check if we're currently in an effect\n    isInEffect(): boolean {\n        return this.activeEffects.size > 0;\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Context } from './context';\n\n/**\n * Batch multiple signal updates to prevent cascading updates\n */\nexport function batch<T>(fn: () => T): T {\n    const context = Context.getInstance();\n    context.beginBatch();\n    try {\n        return fn();\n    } finally {\n        context.endBatch();\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Disposed signal operations\n */\nexport class SignalDisposedError extends Error {\n    constructor(operation: string) {\n        super(`Cannot ${operation} a disposed signal`);\n        this.name = 'SignalDisposedError';\n    }\n}\n\n/**\n * Circular dependency detection\n */\nexport class CircularDependencyError extends Error {\n    constructor(signalName?: string) {\n        super(`Circular dependency detected${signalName ? ` in signal \"${signalName}\"` : ''}`);\n        this.name = 'CircularDependencyError';\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation, SignalOptions, WritableSignal } from './interfaces';\nimport { SignalDisposedError } from './errors';\nimport { EqualityFunction, TransformFunction } from './types';\nimport { Context } from './context';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Base<T> implements WritableSignal<T> {\n    /**\n     * Function to compare previous and next values for equality.\n     * Used to determine if dependents should be notified of changes.\n     */\n    equals: EqualityFunction<T>;\n    /**\n     * Optional name for debugging and identification purposes\n     */\n    name?: string;\n    /**\n     * Set of computations that depend on this signal's value\n     */\n    protected dependents = new Set<IComputation>();\n\n    /**\n     * Flag indicating whether this signal has been disposed\n     */\n    protected disposed = false;\n\n    /**\n     * Creates a new Signal instance\n     *\n     * @param initialValue - The initial value of the signal\n     * @param options - Configuration options for the signal\n     */\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        this._value = initialValue as T;\n        // Use provided equals function or default to Object.is\n        this.equals = options.equals ?? Object.is;\n        this.name = options.name || 'anonymous';\n    }\n\n    isCommutable(): boolean {\n        throw new Error('Method not implemented.');\n    }\n\n    /**\n     * The current value stored in the signal\n     */\n    protected _value: T;\n\n    /**\n     * Gets the current value of the signal.\n     * Tracks dependencies and throws if the signal is disposed.\n     */\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Sets a new value for the signal.\n     * Only updates and notifies dependents if the new value is different from the current value.\n     *\n     * @param newValue - The new value to set\n     */\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('write to');\n        }\n        if (!this.equals(this._value, newValue)) {\n            this._value = newValue;\n            this.notifyDependents();\n        }\n    }\n\n    /**\n     * Gets the current value of the signal without tracking dependencies.\n     */\n    get_value_bypass_tracking(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n        return this._value;\n    }\n\n    /**\n     * Updates the signal's value using a transformation function\n     *\n     * @param fn - Function that takes the current value and returns a new value\n     */\n    update(fn: TransformFunction<T>): void {\n        this.value = fn(this._value);\n    }\n\n\n    /**\n     * Adds a computation as dependent on this signal\n     *\n     * @param computation - The computation to add as a dependent\n     */\n    addDependent(computation: IComputation): void {\n        this.dependents.add(computation);\n    }\n\n    /**\n     * Removes a computation from this signal's dependents\n     *\n     * @param computation - The computation to remove\n     */\n    removeDependent(computation: IComputation): void {\n        this.dependents.delete(computation);\n    }\n\n    /**\n     * Notifies all dependent computations of a value change\n     * Handles batching through SignalContext if active\n     */\n    notifyDependents(): void {\n        const context = Context.getInstance();\n\n        if (context.isBatching()) {\n            context.addToBatchQueue(this);\n            return;\n        }\n\n        for (const dependent of this.dependents) {\n            dependent.markDirty();\n        }\n    }\n\n    /**\n     * Disposes of the signal and its dependent computations\n     * Prevents memory leaks by cleaning up all references\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n\n        // Create a copy of dependents before iterating to avoid modification during iteration\n        const dependentsToDispose = new Set(this.dependents);\n\n        // First, clear own dependents\n        this.dependents.clear();\n\n        // Then dispose all dependent computations\n        for (const dependent of dependentsToDispose) {\n            // @ts-ignore TODO use concrete type\n            if (dependent.constructor.name == 'ComputedSignal'  || dependent['signal']?.constructor.name == 'ComputedSignal') {\n                // If the dependent is or belongs to a ComputedSignal, dispose it\n                // @ts-ignore\n                const signal = dependent.constructor.name == 'ComputedSignal' ? dependent : dependent['signal'];\n                signal.dispose();\n            } else {\n                // For other types of computations, just dispose the computation\n                dependent.dispose();\n            }\n        }\n    }\n\n    /**\n     * Returns whether the signal has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    getDependents(): Set<IComputation> {\n        return this.dependents || new Set();\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    hasDependents(): boolean {\n        return this.dependents.size > 0;\n    }\n\n    toString(): string {\n        return `Signal(${this.name})`;\n    }\n\n    /**\n     * Tracks the current computation as dependent on this signal\n     */\n    protected trackDependency(): void {\n        const computation = Context.getInstance().getCurrentComputation();\n        if (computation) {\n            computation.addDependency(this);\n            this.addDependent(computation);\n        }\n    }\n}\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation } from './interfaces';\n\n/**\n * Manages the scheduling and processing of signal updates\n * Uses a topological sort to handle updates in the correct order\n */\nexport class UpdateQueue {\n    private static instance: UpdateQueue;\n    private queue = new Set<IComputation>();\n    private processing = false;\n    private updateDepth = 0;\n    private maxUpdateDepth = 1000; // Configurable maximum update depth\n\n    static getInstance(): UpdateQueue {\n        if (!this.instance) {\n            this.instance = new UpdateQueue();\n        }\n        return this.instance;\n    }\n\n    /**\n     * Schedule a computation for update\n     */\n    schedule(computation: IComputation): void {\n        if (this.updateDepth >= this.maxUpdateDepth) {\n            throw new Error('Maximum update depth exceeded - possible circular dependency');\n        }\n\n        this.queue.add(computation);\n        if (!this.processing) {\n            this.processQueue();\n        }\n    }\n\n    /**\n     * Process all scheduled updates in dependency order\n     */\n    private processQueue(): void {\n        this.processing = true;\n        this.updateDepth++;\n\n        try {\n            while (this.queue.size > 0) {\n                const computations = Array.from(this.queue);\n                this.queue.clear();\n\n                // Sort by dependency depth to ensure correct update order\n                computations.sort((a, b) => a.getDepth() - b.getDepth());\n\n                for (const computation of computations) {\n                    if (computation.isDirty() && !computation.isDisposed()) {\n                        computation.recompute();\n                    }\n                }\n            }\n        } finally {\n            this.processing = false;\n            this.updateDepth--;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, type WritableSignal } from './interfaces';\nimport { UpdateQueue } from './updateQueue';\n\n/**\n * Base class for managing reactive computations\n */\nexport abstract class Computation implements Disposable, IComputation {\n    protected dirty = true;\n    protected disposed = false;\n    protected dependencies = new Set<WritableSignal<any>>();\n    protected dependents = new Set<Computation>();\n    protected depth = 0;\n    protected name?: string;\n\n    abstract recompute(): void;\n\n    constructor(name?: string) {\n        this.name = name;\n    }\n\n\n    /**\n     * Add a dependency to this computation\n     */\n    addDependency(signal: WritableSignal<any>): void {\n        if (!this.dependencies.has(signal)) {\n            this.dependencies.add(signal);\n            if (signal.constructor.name == 'ComputedSignal') {\n                this.updateDepth();\n            }\n        }\n    }\n\n    /**\n     * Remove a dependency from this computation\n     */\n    removeDependency(signal: WritableSignal<any>): void {\n        if (this.dependencies.delete(signal)) {\n            this.updateDepth();\n        }\n    }\n\n    /**\n     * Clean up computation resources\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        this.clearDependencies();\n        this.dependents.clear();\n    }\n\n    /**\n     * Check if computation is dirty\n     */\n    isDirty(): boolean {\n        return this.dirty;\n    }\n\n    /**\n     * Check if computation has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Add a dependent computation, which will be recomputed when this computation updates\n     */\n    getDepth(): number {\n        return this.depth;\n    }\n\n    /**\n     * Mark computation as dirty and schedule update\n     */\n    markDirty(): void {\n\n        if (!this.disposed) {\n            this.dirty = true;\n            UpdateQueue.getInstance().schedule(this);\n        }\n    }\n\n    /**\n     * Check if signal is a dependency of this computation\n     * @param signal\n     */\n    hasSignal(signal: WritableSignal<any>): boolean {\n        return this.dependencies.has(signal);\n    }\n\n    /**\n     * Clear all dependencies and update depth\n     */\n    clearDependencies(): void {\n        for (const dep of this.dependencies) {\n            dep.removeDependent(this);\n        }\n        this.dependencies.clear();\n        this.updateDepth();\n    }\n\n    /**\n     * Update the computation's depth in the dependency graph\n     */\n    updateDepth(): void {\n        const oldDepth = this.depth;\n        let maxDepth = 0;\n\n        for (const dep of this.dependencies) {\n            if (dep.constructor.name == 'ComputedSignal') {\n                // @ts-ignore TODO use concrete type\n                maxDepth = Math.max(maxDepth, dep.getDepth() + 1);\n            }\n        }\n\n        if (oldDepth !== maxDepth) {\n            this.depth = maxDepth;\n            // Propagate depth update to dependents\n            for (const dependent of this.dependents) {\n                dependent.updateDepth();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Context } from './context';\nimport { Computation } from './computation';\n\nexport class SubscriptionComputation extends Computation {\n    constructor(\n        private callback: () => void\n    ) {\n        super('subscription');\n    }\n\n    recompute(): void {\n        if (this.disposed) return;\n        const context = Context.getInstance();\n        const prevComputation = context.getCurrentComputation();\n        context.setCurrentComputation(this);\n\n        try {\n            this.callback();\n        } finally {\n            if (prevComputation) {\n                context.setCurrentComputation(prevComputation);\n            }\n            this.dirty = false;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Core imports for the Signal implementation\n */\nimport { SignalOptions } from './interfaces';\nimport { UnsubscribeFunction } from './types';\nimport { Base } from './base';\nimport { SignalDisposedError } from './errors';\nimport { SubscriptionComputation } from './SubscriptionComputation';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Signal<T> extends Base<T> {\n\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        super(initialValue, options);\n    }\n\n    /**\n     * Creates a subscription to the signal's value changes\n     *\n     * @param callback - Function to call when the value changes\n     * @returns Function to unsubscribe from changes\n     */\n    subscribe(callback: (value: T) => void): UnsubscribeFunction {\n        if (this.disposed) {\n            throw new SignalDisposedError('subscribe to');\n        }\n        const computed = new SubscriptionComputation(() => {\n            return callback(this.value);\n        });\n\n        computed.recompute();\n\n        return () => computed.dispose();\n    }\n }\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport type { SignalOptions } from './interfaces';\n\n/**\n * Create a new writable signal\n */\nexport function createSignal<T>(\n    initialValue: T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new Signal(initialValue, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Disposable, IEffect } from './interfaces';\nimport { Computation } from './computation';\nimport { Context } from './context';\nimport { Cleanup, EffectFunction } from './types';\n\n\n/**\n * Implementation of reactive effects that automatically track and respond to signal changes.\n * Effects are used to perform side effects in response to reactive updates.\n *\n * @example\n * // Basic effect usage\n * const count = new Signal(0);\n * const dispose = effect(() => {\n *   console.log(`Count changed to: ${count.value}`);\n * });\n * count.value = 1; // Logs: \"Count changed to: 1\"\n * dispose(); // Cleanup effect\n *\n * @example\n * // Effect with cleanup\n * const visible = new Signal(true);\n * const dispose = effect(() => {\n *   if (visible.value) {\n *     const element = document.createElement('div');\n *     document.body.appendChild(element);\n *     // Return cleanup function\n *     return () => {\n *       document.body.removeChild(element);\n *     };\n *   }\n * });\n *\n * @example\n * // Named effect for debugging\n * const timer = new Signal(0);\n * const dispose = effect(() => {\n *   console.log(`Timer: ${timer.value}`);\n * }, 'timerLogger');\n *\n * @example\n * // Effect with multiple dependencies\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n * const dispose = effect(() => {\n *   console.log(`Name changed to: ${firstName.value} ${lastName.value}`);\n * });\n *\n * @example\n * // Effect with error handling\n * const data = new Signal<string | Error>(null);\n * const dispose = effect(() => {\n *   try {\n *     if (data.value instanceof Error) {\n *       console.error('Error:', data.value);\n *     } else {\n *       console.log('Data:', data.value);\n *     }\n *   } catch (error) {\n *     console.error('Effect error:', error);\n *   }\n * });\n */\nexport class EffectImpl implements IEffect {\n    /**\n     * The computation that tracks dependencies and handles recomputation\n     */\n    private readonly computation: Computation;\n\n    /**\n     * Cleanup function from the previous effect execution\n     */\n    cleanup: Cleanup | undefined;\n\n    /**\n     * Flag indicating whether the effect has been disposed\n     */\n    disposed = false;\n\n    /**\n     * Creates a new effect instance\n     *\n     * @param fn - The effect function that may return a cleanup function\n     * @param name - Optional name for debugging purposes\n     */\n    constructor(fn: EffectFunction, name?: string) {\n        this.computation = new class EffectIm extends Computation {\n            // @ts-ignore\n            constructor(private effect: EffectImpl, private fn: EffectFunction) {\n                super(name);\n            }\n\n            /**\n             * Recomputes the effect when dependencies change\n             * Handles proper context management and error boundaries\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = Context.getInstance();\n                context.pushComputation(this);\n\n                try {\n                    context.pushComputation(this);\n                    context.registerEffect(this.effect);\n                    this.effect.runEffect();\n                } finally {\n                    context.unregisterEffect(this.effect);\n                    context.popComputation();\n                    this.dirty = false;\n                }\n            }\n        }(this, fn);\n\n        // Initial computation\n        this.computation.recompute();\n    }\n\n    /**\n     * Disposes of the effect, running cleanup and preventing further executions\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        if (this.cleanup) {\n            try {\n                this.cleanup();\n            } catch (error) {\n                console.error('Error in effect cleanup:', error);\n            }\n        }\n        this.computation.dispose();\n    }\n\n    /**\n     * Executes the effect function and manages cleanup\n     * Handles error boundaries for both effect and cleanup execution\n     */\n    runEffect(): void {\n        if (this.disposed) return;\n\n        // Run cleanup from previous execution\n        if (this.cleanup) {\n            try {\n                this.cleanup();\n            } catch (error) {\n                console.error('Error in effect cleanup:', error);\n            }\n        }\n\n        try {\n            // @ts-ignore - We know this exists from the constructor\n            this.cleanup = this.computation['fn']();\n        } catch (error) {\n            console.error('Error in effect:', error);\n            throw error;\n        }\n    }\n}\n\n/**\n * Creates a new effect that automatically tracks and responds to signal changes\n *\n * @param fn - Effect function that may return a cleanup function\n * @param name - Optional name for debugging purposes\n * @returns A disposable object to cleanup the effect\n *\n * @example\n * // DOM manipulation effect\n * const isVisible = new Signal(true);\n * const dispose = effect(() => {\n *   const element = document.querySelector('.target');\n *   element.style.display = isVisible.value ? 'block' : 'none';\n * });\n *\n * @example\n * // Effect with async operations\n * const userId = new Signal<number | null>(null);\n * const dispose = effect(() => {\n *   const id = userId.value;\n *   if (id !== null) {\n *     let cancelled = false;\n *     fetchUserData(id).then(data => {\n *       if (!cancelled) {\n *         // Handle data\n *       }\n *     });\n *     return () => {\n *       cancelled = true;\n *     };\n *   }\n * });\n */\nexport function effect(fn: EffectFunction, name?: string): Disposable {\n    return new EffectImpl(fn, name);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { createSignal, effect, Signal, SignalOptions } from '../core';\n\n/**\n * Creates a debounced signal that updates its value after a specified delay\n * when the source signal changes.\n *\n * @param source Source signal to watch for changes\n * @param delay Time in milliseconds to wait before updating output\n * @param options Optional signal configuration\n *\n * @example\n * // Basic debouncing of rapid updates\n * const input = new Signal(\"\");\n * const debouncedInput = debounced(input, 300);\n *\n * input.value = \"h\";    // t=0ms\n * input.value = \"he\";   // t=100ms\n * input.value = \"hel\";  // t=200ms\n * input.value = \"hell\"; // t=250ms\n *\n * // debouncedInput.value will be \"hell\" at t=550ms\n *\n * @example\n * // Search input with debouncing\n * const searchQuery = new Signal(\"\");\n * const debouncedSearch = debounced(searchQuery, 500);\n *\n * effect(() => {\n *   // API call only happens 500ms after last keystroke\n *   fetchSearchResults(debouncedSearch.value);\n * });\n *\n * @example\n * // Form validation with debouncing\n * const formData = new Signal({ username: \"\", email: \"\" });\n * const debouncedForm = debounced(formData, 400, {\n *   equals: (a, b) => a.username === b.username && a.email === b.email\n * });\n *\n * effect(() => {\n *   // Validation runs 400ms after user stops typing\n *   validateForm(debouncedForm.value);\n * });\n */\nexport function debounced<T>(\n    source: Signal<T>,\n    delay: number,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const output = createSignal(source.value, options);\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    effect(() => {\n        const value = source.value;\n        if (timeoutId) clearTimeout(timeoutId);\n\n        timeoutId = setTimeout(() => {\n            output.value = value;\n        }, delay);\n\n        return () => {\n            if (timeoutId) clearTimeout(timeoutId);\n        };\n    });\n\n    return output;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { createSignal, effect, Signal, SignalOptions } from '../core';\n\n/**\n * Creates a filtered signal that only updates when the predicate returns true.\n * The output signal follows the source signal's values but only changes when\n * the new value satisfies the given predicate.\n *\n * @param source The input signal to filter\n * @param predicate Function that determines if a value should pass through\n * @param options Optional configuration for the output signal\n * @returns A new signal that only updates when predicate returns true\n *\n * @example\n * const numbers = new Signal(0);\n * const evenNumbers = filtered(numbers, n => n % 2 === 0);\n * numbers.value = 1; // evenNumbers remains 0\n * numbers.value = 2; // evenNumbers updates to 2\n */\nexport function filtered<T>(\n    source: Signal<T>,\n    predicate: (value: T) => boolean,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const output = createSignal(source.value, options);\n\n    effect(() => {\n        const value = source.value;\n        if (predicate(value)) {\n            output.value = value;\n        }\n    });\n\n    return output;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\nimport { Computation } from './computation';\nimport { Context } from './context';\nimport { Signal } from './signal';\nimport type { SignalOptions, WritableSignal } from './interfaces';\nimport { CircularDependencyError, SignalDisposedError } from './errors';\n\n/**\n * Signal that derives its value from other signals\n *\n * @example\n * // Create base signals\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n * // Create a computed signal that depends on firstName and lastName\n * const fullName = new ComputedSignal(() => {\n *   return `${firstName.value} ${lastName.value}`;\n * });\n *\n * console.log(fullName.value); // Output: \"John Doe\"\n *\n * // When a dependency changes, the computed value updates automatically\n * firstName.value = 'Jane';\n * console.log(fullName.value); // Output: \"Jane Doe\"\n */\nexport class ComputedSignal<T> extends Signal<T> {\n\n    /** Internal computation instance to manage dependencies and recomputation */\n    private readonly computation: Computation;\n\n    /** Function that computes the derived value */\n    private computeFn: () => T;\n\n    /**\n     * Creates a new computed signal\n     * @param compute Function that derives the signal value\n     * @param options Configuration options for the signal\n     */\n    constructor(compute: () => T, options: SignalOptions<T> = {}) {\n        super({} as T, options);\n        this.computeFn = compute;\n\n        // Create an anonymous computation class instance\n        this.computation = new class ComputationA extends Computation {\n            constructor(private signal: ComputedSignal<T>) {\n                super();\n            }\n\n            /**\n             * Recomputes the signal value when dependencies change\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = Context.getInstance();\n                const prevComputation = context.getCurrentComputation();\n                context.setCurrentComputation(this);\n\n                // Prevent circular dependencies through effects\n                if (context.isInEffect()) {\n                    throw new CircularDependencyError(\n                        `Cannot create computed signal that depends on effects`,\n                    );\n                }\n\n                try {\n                    // Check if any dependencies have been disposed\n                    for (const dep of this.dependencies) {\n                        if (dep.isDisposed()) {\n                            this.signal.dispose();\n                            throw new SignalDisposedError('read from disposed dependency');\n                        }\n                    }\n\n                    // Compute new value and update if changed\n                    const newValue = this.signal.computeFn();\n                    if (!this.signal.equals(this.signal._value, newValue)) {\n                        this.signal._value = newValue;\n                        this.signal.notifyDependents();\n                    }\n                } catch (error) {\n                    // Handle disposal errors\n                    if (error instanceof SignalDisposedError) {\n                        this.signal.dispose();\n                    }\n                    throw error;\n                } finally {\n                    // Restore previous computation context\n                    if (prevComputation) {\n                        context.setCurrentComputation(prevComputation);\n                    }\n                    this.dirty = false;\n                }\n            }\n        }(this);\n        // Initial computation\n        this.computation.recompute();\n\n    }\n\n    /**\n     * Gets the current value of the computed signal\n     */\n    override get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        // Verify dependencies are still valid\n        const dependencies = this.computation['dependencies'] as Set<WritableSignal<any>>;\n        for (const dep of dependencies) {\n            if (dep.isDisposed()) {\n                this.dispose();\n                throw new SignalDisposedError('read from disposed dependency');\n            }\n        }\n\n        // Recompute if dependencies have changed\n        if (this.computation.isDirty()) {\n            this.computation.recompute();\n        }\n\n        // Track this signal as a dependency for other computations\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Computed signals cannot be set directly\n     */\n    override set value(_: T) {\n        throw new Error('Cannot set the value of a computed signal');\n    }\n\n    /**\n     * Gets the depth of this signal in the dependency graph\n     */\n    getDepth(): number {\n        return this.computation.getDepth();\n    }\n\n    /**\n     * Cleans up the signal and its dependencies\n     */\n    override dispose(): void {\n        if (this.disposed) return;\n\n        super.dispose();\n        this.computation.dispose();\n\n        // Recursively dispose dependent computed signals\n        for (const dependent of this.dependents) {\n            // @ts-ignore\n            if (dependent instanceof ComputedSignal || dependent['signal'] instanceof ComputedSignal) {\n                // @ts-ignore\n                const signal = dependent instanceof ComputedSignal ? dependent : dependent['signal'];\n                signal.dispose();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport { ComputedSignal } from './computedSignal';\nimport type { SignalOptions } from './interfaces';\n\n\n\n/**\n * Create a computed signal that derives its value from other signals\n */\nexport function computed<T>(\n    compute: () => T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new ComputedSignal(compute, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { computed, Signal, SignalOptions } from '../core';\n\n/**\n * Creates a new Signal that transforms the value of a source Signal using a mapping function.\n * The resulting Signal updates automatically when the source Signal changes.\n *\n * @param source The input Signal to transform\n * @param transform Function that converts source value type T to output type U\n * @param options Optional configuration for the resulting Signal\n * @returns A new Signal containing the transformed value\n *\n *\n * @example\n * // Basic transformation of primitive values\n * const count = new Signal(5);\n * const doubled = map(count, n => n * 2);\n * console.log(doubled.value); // 10\n * count.value = 10;\n * console.log(doubled.value); // 20\n *\n * @example\n * // Transforming arrays\n * const numbers = new Signal([1, 2, 3]);\n * const doubled = map(numbers, nums => nums.map(n => n * 2));\n * console.log(doubled.value); // [2, 4, 6]\n *\n * @example\n * // Transforming objects with custom options\n * const user = new Signal({ name: 'John', age: 30 });\n * const userSummary = map(\n *   user,\n *   u => `${u.name} is ${u.age} years old`,\n *   { name: 'userSummary' }\n * );\n * console.log(userSummary.value); // \"John is 30 years old\"\n */\nexport function map<T, U>(\n    source: Signal<T>,\n    transform: (value: T) => U,\n    options?: SignalOptions<U>,\n): Signal<U> {\n    return computed(() => transform(source.value), options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal, Context } from '../core';\n\n\n/**\n * Retrieves the current value of a signal without establishing a dependency relationship.\n * This is useful when you want to read a signal's value without having the current computation\n * track it as a dependency, effectively \"peeking\" at the value without subscribing to changes.\n *\n * @template T The type of value held by the signal\n * @param signal The signal whose value you want to peek at\n * @returns The current value of the signal\n *\n * @description\n * The function works by temporarily manipulating the computation stack:\n * 1. Stores the current computation (if any) from the context\n * 2. Pushes undefined as a temporary computation to prevent dependency tracking\n * 3. Reads the signal's value\n * 4. Restores the previous computation state\n *\n * This approach ensures that when we read the signal's value, it won't be tracked\n * as a dependency in any active computation scope.\n *\n * @example\n * const counter = new Signal(0);\n * // Reading value normally would create a dependency\n * const normalRead = counter.value;\n * // Peeking at value doesn't create a dependency\n * const peekedValue = peek(counter);\n *\n * @example\n * // Useful in computed signals when you need a value for calculation\n * // but don't want to track changes to that specific signal\n * const total = computed(() => {\n *   const current = counter.value;  // Creates dependency\n *   const threshold = peek(maxValue);  // Reads value without dependency\n *   return current > threshold ? current : threshold;\n * });\n */\nexport function peek<T>(signal: Signal<T>): T {\n    const context = Context.getInstance();\n    const prevComputation = context.getCurrentComputation();\n    // @ts-ignore\n    context.setCurrentComputation(undefined);\n    try {\n        return signal.get_value_bypass_tracking(); // Directly access value to bypass dependency tracking\n    } finally {\n        if (prevComputation) {\n            context.setCurrentComputation(prevComputation);\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\nimport { createSignal, Signal } from '../core';\n\n/**\n * Represents an item in the queue with priority and timestamp.\n */\nexport interface QueueItem<T> {\n    id: string;          // Unique identifier for the item\n    data: T;            // The actual data stored in the queue\n    priority: number;   // Priority level (higher numbers = higher priority)\n    timestamp: number;  // Used for FIFO ordering within same priority\n}\n\n/**\n * A priority queue implementation using signals for reactive state management.\n * Items are ordered by priority (highest first) and timestamp (FIFO for same priority).\n *\n * @example\n * // Basic queue operations\n * const taskQueue = createQueueSignal<string>();\n *\n * // Add tasks with different priorities\n * taskQueue.enqueue(\"Low priority task\", 1);\n * taskQueue.enqueue(\"High priority task\", 3);\n * taskQueue.enqueue(\"Medium priority task\", 2);\n *\n * console.log(taskQueue.peek()); // \"High priority task\"\n * console.log(taskQueue.dequeue()); // \"High priority task\"\n * console.log(taskQueue.size()); // 2\n *\n * @example\n * // Task processing with priorities\n * const processingQueue = createQueueSignal<{task: string, urgency: string}>();\n *\n * // Emergency task (priority 3)\n * const emergencyId = processingQueue.enqueue(\n *   {task: \"Server down\", urgency: \"high\"},\n *   3\n * );\n *\n * // Regular tasks (priority 1)\n * processingQueue.enqueue({task: \"Update docs\", urgency: \"low\"}, 1);\n * processingQueue.enqueue({task: \"Code review\", urgency: \"low\"}, 1);\n *\n * // Process emergency first\n * while (!processingQueue.isEmpty()) {\n *   const task = processingQueue.dequeue();\n *   console.log(`Processing: ${task.task}`);\n * }\n *\n * @example\n * // Reactive queue monitoring\n * const downloadQueue = createQueueSignal<string>();\n * const queueSignal = downloadQueue.getQueue();\n *\n * effect(() => {\n *   const items = queueSignal.value;\n *   console.log(`Queue size changed: ${items.length} items`);\n * });\n *\n * downloadQueue.enqueue(\"file1.txt\");\n * downloadQueue.enqueue(\"file2.txt\");\n */\nexport class QueueSignal<T> {\n    private queue: Signal<QueueItem<T>[]>;\n\n    constructor() {\n        this.queue = createSignal<QueueItem<T>[]>([]);\n    }\n\n    /**\n     * Adds an item to the queue with optional priority.\n     * @param data The item to add\n     * @param priority Priority level (higher = more priority)\n     * @returns Unique ID for the queued item\n     */\n    enqueue(data: T, priority: number = 0): string {\n        const id = Math.random().toString(36).substring(2);\n        const item: QueueItem<T> = {\n            id,\n            data,\n            priority,\n            timestamp: Date.now(),\n        };\n\n        this.queue.value = [...this.queue.value, item].sort(\n            (a, b) => b.priority - a.priority || a.timestamp - b.timestamp,\n        );\n\n        return id;\n    }\n\n    /**\n     * Removes and returns the highest priority item.\n     * @returns The data of the dequeued item, or undefined if queue is empty\n     */\n    dequeue(): T | undefined {\n        if (this.isEmpty()) return undefined;\n        const [item, ...rest] = this.queue.value;\n        this.queue.value = rest;\n        return item?.data;\n    }\n\n    /**\n     * Views the next item without removing it.\n     * @returns The data of the next item, or undefined if queue is empty\n     */\n    peek(): T | undefined {\n        return this.queue.value[0]?.data;\n    }\n\n    /**\n     * Removes a specific item by its ID.\n     * @param id ID of the item to remove\n     * @returns true if an item was removed, false otherwise\n     */\n    remove(id: string): boolean {\n        const initialLength = this.queue.value.length;\n        this.queue.value = this.queue.value.filter(item => item.id !== id);\n        return initialLength !== this.queue.value.length;\n    }\n\n    /**\n     * Removes all items from the queue.\n     */\n    clear(): void {\n        this.queue.value = [];\n    }\n\n    /**\n     * Checks if the queue is empty.\n     */\n    isEmpty(): boolean {\n        return this.queue.value.length === 0;\n    }\n\n    /**\n     * Returns the number of items in the queue.\n     */\n    size(): number {\n        return this.queue.value.length;\n    }\n\n    /**\n     * Gets the underlying signal for reactive queue monitoring.\n     * @returns Signal containing the queue items\n     */\n    getQueue(): Signal<QueueItem<T>[]> {\n        return this.queue;\n    }\n}\n\n/**\n * Creates a new queue signal instance.\n * @example\n * // Basic queue operations\n * const taskQueue = createQueueSignal<string>();\n *\n * // Add tasks with different priorities\n * taskQueue.enqueue(\"Low priority task\", 1);\n * taskQueue.enqueue(\"High priority task\", 3);\n * taskQueue.enqueue(\"Medium priority task\", 2);\n *\n * console.log(taskQueue.peek()); // \"High priority task\"\n * console.log(taskQueue.dequeue()); // \"High priority task\"\n * console.log(taskQueue.size()); // 2\n *\n * @example\n * // Task processing with priorities\n * const processingQueue = createQueueSignal<{task: string, urgency: string}>();\n *\n * // Emergency task (priority 3)\n * const emergencyId = processingQueue.enqueue(\n *   {task: \"Server down\", urgency: \"high\"},\n *   3\n * );\n *\n * // Regular tasks (priority 1)\n * processingQueue.enqueue({task: \"Update docs\", urgency: \"low\"}, 1);\n * processingQueue.enqueue({task: \"Code review\", urgency: \"low\"}, 1);\n *\n * // Process emergency first\n * while (!processingQueue.isEmpty()) {\n *   const task = processingQueue.dequeue();\n *   console.log(`Processing: ${task.task}`);\n * }\n *\n * @example\n * // Reactive queue monitoring\n * const downloadQueue = createQueueSignal<string>();\n * const queueSignal = downloadQueue.getQueue();\n *\n * effect(() => {\n *   const items = queueSignal.value;\n *   console.log(`Queue size changed: ${items.length} items`);\n * });\n *\n * @returns A new QueueSignal instance\n */\nexport function createQueueSignal<T>(): QueueSignal<T> {\n    return new QueueSignal<T>();\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { createSignal, effect, Signal, SignalOptions } from '../core';\n\n/**\n * Create a signal that throttles updates\n */\nexport function throttled<T>(\n    source: Signal<T>,\n    interval: number,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const output = createSignal(source.value, options);\n    let lastUpdate = 0;\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    effect(() => {\n        const value = source.value;\n        const now = Date.now();\n\n        if (now - lastUpdate >= interval) {\n            output.value = value;\n            lastUpdate = now;\n        } else if (!timeoutId) {\n            timeoutId = setTimeout(() => {\n                output.value = value;\n                lastUpdate = Date.now();\n                timeoutId = undefined;\n            }, interval - (now - lastUpdate));\n        }\n\n        return () => {\n            if (timeoutId) clearTimeout(timeoutId);\n        };\n    });\n\n    return output;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { computed, Signal, SignalOptions } from '../core';\nimport { peek } from './peek';\n\n/**\n * Creates a Signal that only updates when the source value changes by at least the specified delta.\n * Useful for filtering out small fluctuations in numeric values.\n *\n * @param source - Input Signal containing numeric values\n * @param delta - Minimum change required to trigger an update\n * @param options - Optional Signal configuration\n * @returns A new Signal that updates only on significant changes\n *\n * @example\n * const rawTemp = new Signal(20.0);\n * const filteredTemp = threshold(rawTemp, 0.5);\n * rawTemp.value = 20.2; // filteredTemp stays at 20.0\n * rawTemp.value = 20.6; // filteredTemp updates to 20.6\n */\nexport function threshold<T extends number>(\n    source: Signal<T>,\n    delta: number,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return computed(() => {\n        const value = source.value;\n        const prevValue = peek(source);\n        return Math.abs(value - prevValue) >= delta ? value : prevValue;\n    }, {\n        ...options,\n        equals: (a, b) => Math.abs(a - b) < delta,\n    });\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { computed, createSignal, Signal, SignalOptions } from '../core';\n\n/**\n * Creates a Signal with validation capabilities.\n *\n * @template T - Type of value stored in the signal\n * @param initialValue - Starting value of the signal\n * @param validator - Function that validates new values before they're set\n * @param options - Standard SignalOptions configuration\n * @returns A Signal with validation logic applied to value updates\n *\n * @example\n * // Create a signal that only accepts positive numbers\n * const positiveNum = validated(1,\n *   (value) => value > 0 || \"Value must be positive\"\n * );\n *\n * @example\n * // Create a signal with complex validation and custom equality\n * const user = validated(\n *   { id: 1, name: \"John\" },\n *   (value) => {\n *     if (!value.name) return \"Name is required\";\n *     if (value.id < 0) return \"ID must be positive\";\n *     return true;\n *   },\n *   { equals: (a, b) => a.id === b.id }\n * );\n */\nexport function validated<T>(\n    initialValue: T,\n    validator: (value: T) => boolean | string,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const innerSignal = createSignal(initialValue, options);\n    const validationError = computed(() => {\n        const result = validator(innerSignal.value);\n        if (typeof result === 'string') return result;\n        if (!result) return 'Validation failed';\n        return null;\n    });\n\n    return new Proxy(innerSignal, {\n        get(target, prop) {\n            if (prop === 'value') {\n                const error = validationError.value;\n                if (error) throw new Error(error);\n                return target.value;\n            }\n            return target[prop as keyof typeof target];\n        },\n        set(target, prop, value) {\n            if (prop === 'value') {\n                const result = validator(value);\n                if (typeof result === 'string') throw new Error(result);\n                if (!result) throw new Error('Validation failed');\n                target.value = value;\n            }\n            return true;\n        },\n    });\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Context","computationStack","batchDepth","batchQueue","Set","activeEffects","getInstance","this","instance","getCurrentComputation","length","pushComputation","computation","includes","push","popComputation","pop","isBatching","beginBatch","endBatch","flushBatchQueue","addToBatchQueue","signal","add","uniqueSignals","clear","computations","dependent","getDependents","markDirty","setCurrentComputation","registerEffect","effect","unregisterEffect","delete","isInEffect","size","batch","fn","context","SignalDisposedError","Error","constructor","operation","super","name","CircularDependencyError","signalName","Base","initialValue","options","dependents","disposed","_value","equals","is","isCommutable","trackDependency","newValue","notifyDependents","get_value_bypass_tracking","update","addDependent","removeDependent","dispose","dependentsToDispose","isDisposed","hasDependents","toString","addDependency","UpdateQueue","queue","processing","updateDepth","maxUpdateDepth","schedule","processQueue","Array","from","sort","a","b","getDepth","isDirty","recompute","Computation","dirty","dependencies","depth","has","removeDependency","clearDependencies","hasSignal","dep","oldDepth","maxDepth","Math","max","SubscriptionComputation","callback","prevComputation","Signal","subscribe","computed","createSignal","EffectImpl","runEffect","cleanup","error","debounced","source","delay","output","timeoutId","clearTimeout","setTimeout","filtered","predicate","ComputedSignal","compute","computeFn","_","map","transform","peek","undefined","QueueSignal","enqueue","data","priority","id","random","substring","item","timestamp","Date","now","dequeue","isEmpty","rest","remove","initialLength","filter","getQueue","createQueueSignal","throttled","interval","lastUpdate","threshold","delta","prevValue","abs","validated","validator","innerSignal","validationError","result","Proxy","target","set"],"sourceRoot":""}