{"version":3,"file":"async/index.js","mappings":"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","sources":["webpack://Avati/webpack/universalModuleDefinition","webpack://Avati/webpack/bootstrap","webpack://Avati/webpack/runtime/define property getters","webpack://Avati/webpack/runtime/hasOwnProperty shorthand","webpack://Avati/webpack/runtime/make namespace object","webpack://Avati/./src/core/errors.ts","webpack://Avati/./src/core/context.ts","webpack://Avati/./src/core/base.ts","webpack://Avati/./src/core/updateQueue.ts","webpack://Avati/./src/core/computation.ts","webpack://Avati/./src/core/SubscriptionComputation.ts","webpack://Avati/./src/core/signal.ts","webpack://Avati/./src/async/asyncSignal.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Avati\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Avati\"] = factory();\n\telse\n\t\troot[\"Avati\"] = root[\"Avati\"] || {}, root[\"Avati\"][\"async/index\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Disposed signal operations\n */\nexport class SignalDisposedError extends Error {\n    constructor(operation: string) {\n        super(`Cannot ${operation} a disposed signal`);\n        this.name = 'SignalDisposedError';\n    }\n}\n\n/**\n * Circular dependency detection\n */\nexport class CircularDependencyError extends Error {\n    constructor(signalName?: string) {\n        super(`Circular dependency detected${signalName ? ` in signal \"${signalName}\"` : ''}`);\n        this.name = 'CircularDependencyError';\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, IEffect, WritableSignal } from './interfaces';\n\n/**\n * Manages the global state and context of signal computations\n */\nexport class Context {\n    private static instance: Context;\n    private computationStack: IComputation[] = [];\n    private batchDepth = 0;\n    private batchQueue = new Set<WritableSignal<any>>();\n    private activeEffects = new Set<Disposable>();\n\n    static getInstance(): Context {\n        if (!this.instance) {\n            this.instance = new Context();\n        }\n        return this.instance;\n    }\n\n    getCurrentComputation(): IComputation | undefined {\n        return this.computationStack[this.computationStack.length - 1];\n    }\n\n    pushComputation(computation: IComputation): void {\n        // Check for circular dependencies\n        if (computation && this.computationStack.includes(computation)) {\n            // throw new CircularDependencyError();\n            return;\n        }\n        // we can push undefined to the stack\n        this.computationStack.push(computation);\n    }\n\n    popComputation(): void {\n        this.computationStack.pop();\n    }\n\n    isBatching(): boolean {\n        return this.batchDepth > 0;\n    }\n\n    beginBatch(): void {\n        this.batchDepth++;\n    }\n\n    endBatch(): void {\n        this.batchDepth--;\n        if (this.batchDepth === 0) {\n            this.flushBatchQueue();\n        }\n    }\n\n    addToBatchQueue(signal: WritableSignal<any>): void {\n        this.batchQueue.add(signal);\n    }\n\n    flushBatchQueue(): void {\n        // Create a new Set for unique signals\n        const uniqueSignals = new Set(this.batchQueue);\n        this.batchQueue.clear();\n\n        // Get all dependent computations\n        const computations = new Set<IComputation>();\n\n        for (const signal of uniqueSignals) {\n            for (const dependent of signal.getDependents()) {\n                computations.add(dependent);\n            }\n        }\n        // Mark all computations as dirty\n        for (const computation of computations) {\n            computation.markDirty();\n        }\n    }\n\n    setCurrentComputation(computation: IComputation): void {\n        this.computationStack[this.computationStack.length - 1] = computation;\n    }\n\n\n    registerEffect(effect: IEffect): void {\n        this.activeEffects.add(effect);\n    }\n\n    unregisterEffect(effect: IEffect): void {\n        this.activeEffects.delete(effect);\n    }\n\n    // Add this method to check if we're currently in an effect\n    isInEffect(): boolean {\n        return this.activeEffects.size > 0;\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation, SignalOptions, WritableSignal } from './interfaces';\nimport { SignalDisposedError } from './errors';\nimport { EqualityFunction, TransformFunction } from './types';\nimport { Context } from './context';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Base<T> implements WritableSignal<T> {\n    /**\n     * Function to compare previous and next values for equality.\n     * Used to determine if dependents should be notified of changes.\n     */\n    equals: EqualityFunction<T>;\n    /**\n     * Optional name for debugging and identification purposes\n     */\n    name?: string;\n    /**\n     * Set of computations that depend on this signal's value\n     */\n    protected dependents = new Set<IComputation>();\n\n    /**\n     * Flag indicating whether this signal has been disposed\n     */\n    protected disposed = false;\n\n    /**\n     * Creates a new Signal instance\n     *\n     * @param initialValue - The initial value of the signal\n     * @param options - Configuration options for the signal\n     */\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        this._value = initialValue as T;\n        // Use provided equals function or default to Object.is\n        this.equals = options.equals ?? Object.is;\n        this.name = options.name || 'anonymous';\n    }\n\n    isCommutable(): boolean {\n        throw new Error('Method not implemented.');\n    }\n\n    /**\n     * The current value stored in the signal\n     */\n    protected _value: T;\n\n    /**\n     * Gets the current value of the signal.\n     * Tracks dependencies and throws if the signal is disposed.\n     */\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Sets a new value for the signal.\n     * Only updates and notifies dependents if the new value is different from the current value.\n     *\n     * @param newValue - The new value to set\n     */\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('write to');\n        }\n        if (!this.equals(this._value, newValue)) {\n            this._value = newValue;\n            this.notifyDependents();\n        }\n    }\n\n    /**\n     * Gets the current value of the signal without tracking dependencies.\n     */\n    get_value_bypass_tracking(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n        return this._value;\n    }\n\n    /**\n     * Updates the signal's value using a transformation function\n     *\n     * @param fn - Function that takes the current value and returns a new value\n     */\n    update(fn: TransformFunction<T>): void {\n        this.value = fn(this._value);\n    }\n\n\n    /**\n     * Adds a computation as dependent on this signal\n     *\n     * @param computation - The computation to add as a dependent\n     */\n    addDependent(computation: IComputation): void {\n        this.dependents.add(computation);\n    }\n\n    /**\n     * Removes a computation from this signal's dependents\n     *\n     * @param computation - The computation to remove\n     */\n    removeDependent(computation: IComputation): void {\n        this.dependents.delete(computation);\n    }\n\n    /**\n     * Notifies all dependent computations of a value change\n     * Handles batching through SignalContext if active\n     */\n    notifyDependents(): void {\n        const context = Context.getInstance();\n\n        if (context.isBatching()) {\n            context.addToBatchQueue(this);\n            return;\n        }\n\n        for (const dependent of this.dependents) {\n            dependent.markDirty();\n        }\n    }\n\n    /**\n     * Disposes of the signal and its dependent computations\n     * Prevents memory leaks by cleaning up all references\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n\n        // Create a copy of dependents before iterating to avoid modification during iteration\n        const dependentsToDispose = new Set(this.dependents);\n\n        // First, clear own dependents\n        this.dependents.clear();\n\n        // Then dispose all dependent computations\n        for (const dependent of dependentsToDispose) {\n            // @ts-ignore TODO use concrete type\n            if (dependent.constructor.name == 'ComputedSignal'  || dependent['signal']?.constructor.name == 'ComputedSignal') {\n                // If the dependent is or belongs to a ComputedSignal, dispose it\n                // @ts-ignore\n                const signal = dependent.constructor.name == 'ComputedSignal' ? dependent : dependent['signal'];\n                signal.dispose();\n            } else {\n                // For other types of computations, just dispose the computation\n                dependent.dispose();\n            }\n        }\n    }\n\n    /**\n     * Returns whether the signal has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    getDependents(): Set<IComputation> {\n        return this.dependents || new Set();\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    hasDependents(): boolean {\n        return this.dependents.size > 0;\n    }\n\n    toString(): string {\n        return `Signal(${this.name})`;\n    }\n\n    /**\n     * Tracks the current computation as dependent on this signal\n     */\n    protected trackDependency(): void {\n        const computation = Context.getInstance().getCurrentComputation();\n        if (computation) {\n            computation.addDependency(this);\n            this.addDependent(computation);\n        }\n    }\n}\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation } from './interfaces';\n\n/**\n * Manages the scheduling and processing of signal updates\n * Uses a topological sort to handle updates in the correct order\n */\nexport class UpdateQueue {\n    private static instance: UpdateQueue;\n    private queue = new Set<IComputation>();\n    private processing = false;\n    private updateDepth = 0;\n    private maxUpdateDepth = 1000; // Configurable maximum update depth\n\n    static getInstance(): UpdateQueue {\n        if (!this.instance) {\n            this.instance = new UpdateQueue();\n        }\n        return this.instance;\n    }\n\n    /**\n     * Schedule a computation for update\n     */\n    schedule(computation: IComputation): void {\n        if (this.updateDepth >= this.maxUpdateDepth) {\n            throw new Error('Maximum update depth exceeded - possible circular dependency');\n        }\n\n        this.queue.add(computation);\n        if (!this.processing) {\n            this.processQueue();\n        }\n    }\n\n    /**\n     * Process all scheduled updates in dependency order\n     */\n    private processQueue(): void {\n        this.processing = true;\n        this.updateDepth++;\n\n        try {\n            while (this.queue.size > 0) {\n                const computations = Array.from(this.queue);\n                this.queue.clear();\n\n                // Sort by dependency depth to ensure correct update order\n                computations.sort((a, b) => a.getDepth() - b.getDepth());\n\n                for (const computation of computations) {\n                    if (computation.isDirty() && !computation.isDisposed()) {\n                        computation.recompute();\n                    }\n                }\n            }\n        } finally {\n            this.processing = false;\n            this.updateDepth--;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, type WritableSignal } from './interfaces';\nimport { UpdateQueue } from './updateQueue';\n\n/**\n * Base class for managing reactive computations\n */\nexport abstract class Computation implements Disposable, IComputation {\n    protected dirty = true;\n    protected disposed = false;\n    protected dependencies = new Set<WritableSignal<any>>();\n    protected dependents = new Set<Computation>();\n    protected depth = 0;\n    protected name?: string;\n\n    abstract recompute(): void;\n\n    constructor(name?: string) {\n        this.name = name;\n    }\n\n\n    /**\n     * Add a dependency to this computation\n     */\n    addDependency(signal: WritableSignal<any>): void {\n        if (!this.dependencies.has(signal)) {\n            this.dependencies.add(signal);\n            if (signal.constructor.name == 'ComputedSignal') {\n                this.updateDepth();\n            }\n        }\n    }\n\n    /**\n     * Remove a dependency from this computation\n     */\n    removeDependency(signal: WritableSignal<any>): void {\n        if (this.dependencies.delete(signal)) {\n            this.updateDepth();\n        }\n    }\n\n    /**\n     * Clean up computation resources\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        this.clearDependencies();\n        this.dependents.clear();\n    }\n\n    /**\n     * Check if computation is dirty\n     */\n    isDirty(): boolean {\n        return this.dirty;\n    }\n\n    /**\n     * Check if computation has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Add a dependent computation, which will be recomputed when this computation updates\n     */\n    getDepth(): number {\n        return this.depth;\n    }\n\n    /**\n     * Mark computation as dirty and schedule update\n     */\n    markDirty(): void {\n\n        if (!this.disposed) {\n            this.dirty = true;\n            UpdateQueue.getInstance().schedule(this);\n        }\n    }\n\n    /**\n     * Check if signal is a dependency of this computation\n     * @param signal\n     */\n    hasSignal(signal: WritableSignal<any>): boolean {\n        return this.dependencies.has(signal);\n    }\n\n    /**\n     * Clear all dependencies and update depth\n     */\n    clearDependencies(): void {\n        for (const dep of this.dependencies) {\n            dep.removeDependent(this);\n        }\n        this.dependencies.clear();\n        this.updateDepth();\n    }\n\n    /**\n     * Update the computation's depth in the dependency graph\n     */\n    updateDepth(): void {\n        const oldDepth = this.depth;\n        let maxDepth = 0;\n\n        for (const dep of this.dependencies) {\n            if (dep.constructor.name == 'ComputedSignal') {\n                // @ts-ignore TODO use concrete type\n                maxDepth = Math.max(maxDepth, dep.getDepth() + 1);\n            }\n        }\n\n        if (oldDepth !== maxDepth) {\n            this.depth = maxDepth;\n            // Propagate depth update to dependents\n            for (const dependent of this.dependents) {\n                dependent.updateDepth();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Context } from './context';\nimport { Computation } from './computation';\n\nexport class SubscriptionComputation extends Computation {\n    constructor(\n        private callback: () => void\n    ) {\n        super('subscription');\n    }\n\n    recompute(): void {\n        if (this.disposed) return;\n        const context = Context.getInstance();\n        const prevComputation = context.getCurrentComputation();\n        context.setCurrentComputation(this);\n\n        try {\n            this.callback();\n        } finally {\n            if (prevComputation) {\n                context.setCurrentComputation(prevComputation);\n            }\n            this.dirty = false;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Core imports for the Signal implementation\n */\nimport { SignalOptions } from './interfaces';\nimport { UnsubscribeFunction } from './types';\nimport { Base } from './base';\nimport { SignalDisposedError } from './errors';\nimport { SubscriptionComputation } from './SubscriptionComputation';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Signal<T> extends Base<T> {\n\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        super(initialValue, options);\n    }\n\n    /**\n     * Creates a subscription to the signal's value changes\n     *\n     * @param callback - Function to call when the value changes\n     * @returns Function to unsubscribe from changes\n     */\n    subscribe(callback: (value: T) => void): UnsubscribeFunction {\n        if (this.disposed) {\n            throw new SignalDisposedError('subscribe to');\n        }\n        const computed = new SubscriptionComputation(() => {\n            return callback(this.value);\n        });\n\n        computed.recompute();\n\n        return () => computed.dispose();\n    }\n }\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Signal, SignalOptions } from '../core';\n\n/**\n * Represents the state of an asynchronous operation\n * @template T The type of data being fetched\n * @template E The type of error (defaults to Error)\n */\nexport interface AsyncState<T, E = Error> {\n    /** The fetched data */\n    data: T | null;\n    /** Whether a fetch is in progress */\n    loading: boolean;\n    /** Any error that occurred during fetch */\n    error: E | null;\n    /** When the data was last fetched */\n    timestamp: number;\n}\n\n/**\n * Configuration options for AsyncSignal\n * @template T The type of data being fetched\n * @template E The type of error\n *\n * @example\n * // Basic caching config\n * const options: AsyncSignalOptions<User> = {\n *   cache: {\n *     enabled: true,\n *     ttl: 5 * 60 * 1000 // 5 minutes\n *   }\n * };\n *\n * @example\n * // Retry with exponential backoff\n * const options: AsyncSignalOptions<User> = {\n *   retryConfig: {\n *     attempts: 3,      // Try 3 times\n *     delay: 1000,      // Start with 1s delay\n *     backoffFactor: 2  // Double delay each retry: 1s, 2s, 4s\n *   }\n * };\n *\n * @example\n * // With analytics callbacks\n * const options: AsyncSignalOptions<User> = {\n *   onSuccess: (user) => {\n *     analytics.track('userFetched', { userId: user.id });\n *     updateUI(user);\n *   },\n *   onError: (error) => {\n *     errorReporting.capture(error);\n *     showErrorToast(error.message);\n *   }\n * };\n */\nexport interface AsyncSignalOptions<T, E = Error> extends SignalOptions<AsyncState<T, E>> {\n    cache?: {\n        enabled: boolean;   //\n        ttl?: number;      // How long to cache results (ms)\n    };\n    retryConfig?: {\n        attempts: number;    // Maximum retry attempts\n        delay: number;      // Initial delay between retries (ms)\n        backoffFactor: number; // How much to increase delay each retry\n    };\n    onError?: (error: E) => void;    // Error callback\n    onSuccess?: (data: T) => void;   // Success callback\n}\n\n/**\n * A Signal subclass for managing asynchronous operations with built-in\n * loading states, caching, and retry logic\n *\n * @template T Type of data being fetched\n * @template E Type of error that can occur\n *\n * @example\n * // User authentication with error handling\n * interface User {\n *   id: string;\n *   name: string;\n *   email: string;\n * }\n *\n * interface AuthError {\n *   code: 'invalid_credentials' | 'network_error' | 'server_error';\n *   message: string;\n * }\n *\n * const authSignal = new AsyncSignal<User, AuthError>(\n *   async () => {\n *     const response = await fetch('/api/auth');\n *     if (!response.ok) {\n *       throw {\n *         code: 'invalid_credentials',\n *         message: 'Invalid username or password'\n *       };\n *     }\n *     return response.json();\n *   },\n *   {\n *     cache: { enabled: true, ttl: 30 * 60 * 1000 }, // 30min cache\n *     onError: (error) => {\n *       if (error.code === 'invalid_credentials') {\n *         showLoginForm();\n *       } else {\n *         showErrorDialog(error.message);\n *       }\n *     }\n *   }\n * );\n *\n * @example\n * // Real-time search with request cancellation\n * const searchSignal = new AsyncSignal(\n *   async (query: string) => {\n *     const response = await fetch(`/api/search?q=${query}`);\n *     return response.json();\n *   }\n * );\n *\n * searchInput.addEventListener('input', async (e) => {\n *   const results = await searchSignal.fetch(); // Auto-cancels previous\n *   updateSearchResults(results);\n * });\n *\n * @example\n * // File upload with progress tracking\n * const uploadSignal = new AsyncSignal<string>(\n *   async (file: File) => {\n *     const formData = new FormData();\n *     formData.append('file', file);\n *\n *     const response = await fetch('/api/upload', {\n *       method: 'POST',\n *       body: formData\n *     });\n *\n *     if (!response.ok) {\n *       throw new Error('Upload failed');\n *     }\n *\n *     const { url } = await response.json();\n *     return url;\n *   },\n *   {\n *     retryConfig: {\n *       attempts: 3,\n *       delay: 2000,\n *       backoffFactor: 1.5\n *     },\n *     onSuccess: (url) => {\n *       showSuccess(`File uploaded to ${url}`);\n *     }\n *   }\n * );\n *\n * @example\n * // Polling with caching\n * const pollSignal = new AsyncSignal<JobStatus>(\n *   async (jobId: string) => {\n *     const response = await fetch(`/api/jobs/${jobId}`);\n *     return response.json();\n *   },\n *   {\n *     cache: {\n *       enabled: true,\n *       ttl: 5000 // Cache for 5s between polls\n *     }\n *   }\n * );\n *\n * const pollJob = async (jobId: string) => {\n *   while (true) {\n *     const status = await pollSignal.fetch();\n *     if (status.state === 'completed') break;\n *     await new Promise(resolve => setTimeout(resolve, 5000));\n *   }\n * };\n */\nexport class AsyncSignal<T, E = Error> extends Signal<AsyncState<T, E>> {\n    private readonly fetchFn: () => Promise<T>;\n    private options: AsyncSignalOptions<T, E>;\n    private abortController: AbortController | null = null;\n\n    constructor(\n        fetchFn: () => Promise<T>,\n        options: AsyncSignalOptions<T, E> = {},\n    ) {\n        super({\n            data: null,\n            loading: false,\n            error: null,\n            timestamp: 0,\n        }, options);\n\n        this.fetchFn = fetchFn;\n        this.options = options;\n    }\n\n    /**\n     * Fetches data using the provided fetch function\n     * Handles loading states, caching, retries, and error handling\n     *\n     * @param force Whether to bypass cache and force a new fetch\n     * @returns The fetched data or null if fetch failed\n     *\n     * @example\n     * const signal = new AsyncSignal(fetchUser);\n     * await signal.fetch(); // Normal fetch, uses cache if valid\n     * await signal.fetch(true); // Force fetch, bypass cache\n     */\n    async fetch(force: boolean = false): Promise<T | null> {\n        // Check cache unless forced refresh\n        if (this.isCacheValid() && !force) {\n            return this.value.data;\n        }\n\n        // Cancel any in-flight request\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n        this.abortController = new AbortController();\n\n        // Set loading state\n        this.value = {\n            ...this.value,\n            loading: true,\n            error: null,\n        };\n\n        // Initialize retry loop variables\n        let attempts = 0;\n        const maxAttempts = this.options.retryConfig?.attempts || 1;\n        const delay = this.options.retryConfig?.delay || 1000;\n        const backoffFactor = this.options.retryConfig?.backoffFactor || 2;\n\n        // Retry loop\n        while (attempts < maxAttempts) {\n            try {\n                const data = await this.fetchFn();\n                // Update state on success\n                this.value = {\n                    data,\n                    loading: false,\n                    error: null,\n                    timestamp: Date.now(),\n                };\n                this.options.onSuccess?.(data);\n                return data;\n            } catch (error) {\n                attempts++;\n                // If out of retries, set error state\n                if (attempts === maxAttempts) {\n                    this.value = {\n                        ...this.value,\n                        loading: false,\n                        error: error as E,\n                    };\n                    this.options.onError?.(error as E);\n                    return null;\n                }\n                // Wait before retrying with exponential backoff\n                await new Promise(resolve =>\n                    setTimeout(resolve, delay * Math.pow(backoffFactor, attempts - 1)),\n                );\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Forces a fresh fetch, bypassing cache\n     */\n    refresh(): Promise<T | null> {\n        return this.fetch(true);\n    }\n\n    /**\n     * Cleans up by aborting any in-flight request\n     */\n    override dispose(): void {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n        super.dispose();\n    }\n\n    /**\n     * Checks if cached data is still valid based on TTL\n     */\n    private isCacheValid(): boolean {\n        if (!this.options.cache?.enabled) return false;\n        if (!this.value.data) return false;\n\n        const ttl = this.options.cache.ttl || 5 * 60 * 1000; // Default 5 minutes\n        return Date.now() - this.value.timestamp < ttl;\n    }\n}\n\n/**\n * Factory function to create AsyncSignal instances\n *\n * @example\n * // Example 1: Simple user fetch with caching\n * const userSignal = asyncSignal(\n *   async () => {\n *     const response = await fetch('/api/user');\n *     return response.json();\n *   },\n *   {\n *     cache: { enabled: true, ttl: 60000 } // Cache for 1 minute\n *   }\n * );\n *\n * @example\n * // Example 2: Weather API with retries\n * const weatherSignal = asyncSignal(\n *   async () => {\n *     const response = await fetch('https://api.weather.com/current');\n *     return response.json();\n *   },\n *   {\n *     retryConfig: {\n *       attempts: 3,\n *       delay: 1000,\n *       backoffFactor: 2\n *     }\n *   }\n * );\n *\n * @example\n * // Example 3: Todo list with error handling\n * const todoSignal = asyncSignal(\n *   async () => {\n *     const response = await fetch('/api/todos');\n *     if (!response.ok) throw new Error('Failed to fetch todos');\n *     return response.json();\n *   },\n *   {\n *     onError: (error) => console.error('Todo fetch failed:', error),\n *     onSuccess: (todos) => console.log('Fetched todos:', todos.length)\n *   }\n * );\n */\nexport function asyncSignal<T, E = Error>(\n    fetchFn: () => Promise<T>,\n    options?: AsyncSignalOptions<T, E>,\n): AsyncSignal<T, E> {\n    return new AsyncSignal(fetchFn, options);\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","SignalDisposedError","Error","constructor","operation","super","name","Context","computationStack","batchDepth","batchQueue","Set","activeEffects","getInstance","instance","getCurrentComputation","length","pushComputation","computation","includes","push","popComputation","pop","isBatching","beginBatch","endBatch","flushBatchQueue","addToBatchQueue","signal","add","uniqueSignals","clear","computations","dependent","getDependents","markDirty","setCurrentComputation","registerEffect","effect","unregisterEffect","delete","isInEffect","size","Base","initialValue","options","dependents","disposed","_value","equals","is","isCommutable","trackDependency","newValue","notifyDependents","get_value_bypass_tracking","update","fn","addDependent","removeDependent","context","dispose","dependentsToDispose","isDisposed","hasDependents","toString","addDependency","UpdateQueue","queue","processing","updateDepth","maxUpdateDepth","schedule","processQueue","Array","from","sort","a","b","getDepth","isDirty","recompute","Computation","dirty","dependencies","depth","has","removeDependency","clearDependencies","hasSignal","dep","oldDepth","maxDepth","Math","max","SubscriptionComputation","callback","prevComputation","Signal","subscribe","computed","AsyncSignal","fetchFn","data","loading","error","timestamp","abortController","fetch","force","isCacheValid","abort","AbortController","attempts","maxAttempts","retryConfig","delay","backoffFactor","Date","now","onSuccess","onError","Promise","resolve","setTimeout","pow","refresh","cache","enabled","ttl","asyncSignal"],"sourceRoot":""}