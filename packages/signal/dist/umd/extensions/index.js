/*!
 * @avatijs/signal 0.2.1
 * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://avati.io/ for details.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Avati",[],e):"object"==typeof exports?exports.Avati=e():(t.Avati=t.Avati||{},t.Avati.extensions=e())}("undefined"!=typeof self?self:this,(()=>(()=>{"use strict";var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"t",{value:!0})}},e={};t.r(e),t.d(e,{batch:()=>i,createQueueSignal:()=>b,createSignal:()=>f,debounced:()=>p,filtered:()=>m,map:()=>g,peek:()=>v,threshold:()=>C,throttled:()=>D,validated:()=>E});class s{constructor(){this.computationStack=[],this.batchDepth=0,this.batchQueue=new Set,this.activeEffects=new Set}static getInstance(){return this.instance||(this.instance=new s),this.instance}getCurrentComputation(){return this.computationStack[this.computationStack.length-1]}pushComputation(t){t&&this.computationStack.includes(t)||this.computationStack.push(t)}popComputation(){this.computationStack.pop()}isBatching(){return this.batchDepth>0}beginBatch(){this.batchDepth++}endBatch(){this.batchDepth--,0===this.batchDepth&&this.flushBatchQueue()}addToBatchQueue(t){this.batchQueue.add(t)}flushBatchQueue(){const t=new Set(this.batchQueue);this.batchQueue.clear();const e=new Set;for(const s of t)for(const t of s.getDependents())e.add(t);for(const t of e)t.markDirty()}setCurrentComputation(t){this.computationStack[this.computationStack.length-1]=t}registerEffect(t){this.activeEffects.add(t)}unregisterEffect(t){this.activeEffects.delete(t)}isInEffect(){return this.activeEffects.size>0}}function i(t){const e=s.getInstance();e.beginBatch();try{return t()}finally{e.endBatch()}}class n extends Error{constructor(t){super(`Cannot ${t} a disposed signal`),this.name="SignalDisposedError"}}class r extends Error{constructor(t){super("Circular dependency detected"+(t?` in signal "${t}"`:"")),this.name="CircularDependencyError"}}class o{constructor(t,e={}){var s;this.dependents=new Set,this.disposed=!1,this.i=t,this.equals=null!==(s=e.equals)&&void 0!==s?s:Object.is,this.name=e.name||"anonymous"}isCommutable(){throw Error("Method not implemented.")}get value(){if(this.disposed)throw new n("read from");return this.trackDependency(),this.i}set value(t){if(this.disposed)throw new n("write to");this.equals(this.i,t)||(this.i=t,this.notifyDependents())}get_value_bypass_tracking(){if(this.disposed)throw new n("read from");return this.i}update(t){this.value=t(this.i)}addDependent(t){this.dependents.add(t)}removeDependent(t){this.dependents.delete(t)}notifyDependents(){const t=s.getInstance();if(t.isBatching())t.addToBatchQueue(this);else for(const t of this.dependents)t.markDirty()}dispose(){var t;if(this.disposed)return;this.disposed=!0;const e=new Set(this.dependents);this.dependents.clear();for(const s of e)"ComputedSignal"==s.constructor.name||"ComputedSignal"==(null===(t=s.signal)||void 0===t?void 0:t.constructor.name)?("ComputedSignal"==s.constructor.name?s:s.signal).dispose():s.dispose()}isDisposed(){return this.disposed}getDependents(){return this.dependents||new Set}hasDependents(){return this.dependents.size>0}toString(){return`Signal(${this.name})`}trackDependency(){const t=s.getInstance().getCurrentComputation();t&&(t.addDependency(this),this.addDependent(t))}}class h{constructor(){this.queue=new Set,this.processing=!1,this.updateDepth=0,this.maxUpdateDepth=1e3}static getInstance(){return this.instance||(this.instance=new h),this.instance}schedule(t){if(this.updateDepth>=this.maxUpdateDepth)throw Error("Maximum update depth exceeded - possible circular dependency");this.queue.add(t),this.processing||this.processQueue()}processQueue(){this.processing=!0,this.updateDepth++;try{for(;this.queue.size>0;){const t=Array.from(this.queue);this.queue.clear(),t.sort(((t,e)=>t.getDepth()-e.getDepth()));for(const e of t)e.isDirty()&&!e.isDisposed()&&e.recompute()}}finally{this.processing=!1,this.updateDepth--}}}class c{constructor(t){this.dirty=!0,this.disposed=!1,this.dependencies=new Set,this.dependents=new Set,this.depth=0,this.name=t}addDependency(t){this.dependencies.has(t)||(this.dependencies.add(t),"ComputedSignal"==t.constructor.name&&this.updateDepth())}removeDependency(t){this.dependencies.delete(t)&&this.updateDepth()}dispose(){this.disposed||(this.disposed=!0,this.clearDependencies(),this.dependents.clear())}isDirty(){return this.dirty}isDisposed(){return this.disposed}getDepth(){return this.depth}markDirty(){this.disposed||(this.dirty=!0,h.getInstance().schedule(this))}hasSignal(t){return this.dependencies.has(t)}clearDependencies(){for(const t of this.dependencies)t.removeDependent(this);this.dependencies.clear(),this.updateDepth()}updateDepth(){const t=this.depth;let e=0;for(const t of this.dependencies)"ComputedSignal"==t.constructor.name&&(e=Math.max(e,t.getDepth()+1));if(t!==e){this.depth=e;for(const t of this.dependents)t.updateDepth()}}}class u extends c{constructor(t){super("subscription"),this.callback=t}recompute(){if(this.disposed)return;const t=s.getInstance(),e=t.getCurrentComputation();t.setCurrentComputation(this);try{this.callback()}finally{e&&t.setCurrentComputation(e),this.dirty=!1}}}class a extends o{constructor(t,e={}){super(t,e)}subscribe(t){if(this.disposed)throw new n("subscribe to");const e=new u((()=>t(this.value)));return e.recompute(),()=>e.dispose()}}function f(t,e){return new a(t,e)}class d{constructor(t,e){this.disposed=!1,this.computation=new class extends c{constructor(t,s){super(e),this.effect=t,this.fn=s}recompute(){if(this.disposed)return;const t=s.getInstance();t.pushComputation(this);try{t.pushComputation(this),t.registerEffect(this.effect),this.effect.runEffect()}finally{t.unregisterEffect(this.effect),t.popComputation(),this.dirty=!1}}}(this,t),this.computation.recompute()}dispose(){if(!this.disposed){if(this.disposed=!0,this.cleanup)try{this.cleanup()}catch(t){}this.computation.dispose()}}runEffect(){if(!this.disposed){if(this.cleanup)try{this.cleanup()}catch(t){}try{this.cleanup=this.computation.fn()}catch(t){throw t}}}}function l(t,e){return new d(t,e)}function p(t,e,s){const i=f(t.value,s);let n;return l((()=>{const s=t.value;return n&&clearTimeout(n),n=setTimeout((()=>{i.value=s}),e),()=>{n&&clearTimeout(n)}})),i}function m(t,e,s){const i=f(t.value,s);return l((()=>{const s=t.value;e(s)&&(i.value=s)})),i}class w extends a{constructor(t,e={}){super({},e),this.computeFn=t,this.computation=new class extends c{constructor(t){super(),this.signal=t}recompute(){if(this.disposed)return;const t=s.getInstance(),e=t.getCurrentComputation();if(t.setCurrentComputation(this),t.isInEffect())throw new r("Cannot create computed signal that depends on effects");try{for(const t of this.dependencies)if(t.isDisposed())throw this.signal.dispose(),new n("read from disposed dependency");const t=this.signal.computeFn();this.signal.equals(this.signal.i,t)||(this.signal.i=t,this.signal.notifyDependents())}catch(t){throw t instanceof n&&this.signal.dispose(),t}finally{e&&t.setCurrentComputation(e),this.dirty=!1}}}(this),this.computation.recompute()}get value(){if(this.disposed)throw new n("read from");const t=this.computation.dependencies;for(const e of t)if(e.isDisposed())throw this.dispose(),new n("read from disposed dependency");return this.computation.isDirty()&&this.computation.recompute(),this.trackDependency(),this.i}set value(t){throw Error("Cannot set the value of a computed signal")}getDepth(){return this.computation.getDepth()}dispose(){if(!this.disposed){super.dispose(),this.computation.dispose();for(const t of this.dependents)(t instanceof w||t.signal instanceof w)&&(t instanceof w?t:t.signal).dispose()}}}function y(t,e){return new w(t,e)}function g(t,e,s){return y((()=>e(t.value)),s)}function v(t){const e=s.getInstance(),i=e.getCurrentComputation();e.setCurrentComputation(void 0);try{return t.get_value_bypass_tracking()}finally{i&&e.setCurrentComputation(i)}}class S{constructor(){this.queue=f([])}enqueue(t,e=0){const s=Math.random().toString(36).substring(2),i={id:s,data:t,priority:e,timestamp:Date.now()};return this.queue.value=[...this.queue.value,i].sort(((t,e)=>e.priority-t.priority||t.timestamp-e.timestamp)),s}dequeue(){if(this.isEmpty())return;const[t,...e]=this.queue.value;return this.queue.value=e,null==t?void 0:t.data}peek(){var t;return null===(t=this.queue.value[0])||void 0===t?void 0:t.data}remove(t){const e=this.queue.value.length;return this.queue.value=this.queue.value.filter((e=>e.id!==t)),e!==this.queue.value.length}clear(){this.queue.value=[]}isEmpty(){return 0===this.queue.value.length}size(){return this.queue.value.length}getQueue(){return this.queue}}function b(){return new S}function D(t,e,s){const i=f(t.value,s);let n,r=0;return l((()=>{const s=t.value,o=Date.now();return e>o-r?n||(n=setTimeout((()=>{i.value=s,r=Date.now(),n=void 0}),e-(o-r))):(i.value=s,r=o),()=>{n&&clearTimeout(n)}})),i}function C(t,e,s){return y((()=>{const s=t.value,i=v(t);return e>Math.abs(s-i)?i:s}),{...s,equals:(t,s)=>e>Math.abs(t-s)})}function E(t,e,s){const i=f(t,s),n=y((()=>{const t=e(i.value);return"string"==typeof t?t:t?null:"Validation failed"}));return new Proxy(i,{get(t,e){if("value"===e){const e=n.value;if(e)throw Error(e);return t.value}return t[e]},set(t,s,i){if("value"===s){const s=e(i);if("string"==typeof s)throw Error(s);if(!s)throw Error("Validation failed");t.value=i}return!0}})}return e})()));
//# sourceMappingURL=index.js.map