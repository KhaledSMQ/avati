{"version":3,"file":"computed/index.js","mappings":"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","sources":["webpack://Avati.computed/webpack/universalModuleDefinition","webpack://Avati.computed/webpack/bootstrap","webpack://Avati.computed/webpack/runtime/define property getters","webpack://Avati.computed/webpack/runtime/hasOwnProperty shorthand","webpack://Avati.computed/webpack/runtime/make namespace object","webpack://Avati.computed/./src/core/updateQueue.ts","webpack://Avati.computed/./src/core/computation.ts","webpack://Avati.computed/./src/core/context.ts","webpack://Avati.computed/./src/core/errors.ts","webpack://Avati.computed/./src/core/base.ts","webpack://Avati.computed/./src/core/SubscriptionComputation.ts","webpack://Avati.computed/./src/core/signal.ts","webpack://Avati.computed/./src/core/computedSignal.ts","webpack://Avati.computed/./src/core/computed.ts","webpack://Avati.computed/./src/computed/combine.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Avati\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Avati\"] = factory();\n\telse\n\t\troot[\"Avati\"] = root[\"Avati\"] || {}, root[\"Avati\"][\"computed\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation } from './interfaces';\n\n/**\n * Manages the scheduling and processing of signal updates\n * Uses a topological sort to handle updates in the correct order\n */\nexport class UpdateQueue {\n    private static instance: UpdateQueue;\n    private queue = new Set<IComputation>();\n    private processing = false;\n    private updateDepth = 0;\n    private maxUpdateDepth = 1000; // Configurable maximum update depth\n\n    static getInstance(): UpdateQueue {\n        if (!this.instance) {\n            this.instance = new UpdateQueue();\n        }\n        return this.instance;\n    }\n\n    /**\n     * Schedule a computation for update\n     */\n    schedule(computation: IComputation): void {\n        if (this.updateDepth >= this.maxUpdateDepth) {\n            throw new Error('Maximum update depth exceeded - possible circular dependency');\n        }\n\n        this.queue.add(computation);\n        if (!this.processing) {\n            this.processQueue();\n        }\n    }\n\n    /**\n     * Process all scheduled updates in dependency order\n     */\n    private processQueue(): void {\n        this.processing = true;\n        this.updateDepth++;\n\n        try {\n            while (this.queue.size > 0) {\n                const computations = Array.from(this.queue);\n                this.queue.clear();\n\n                // Sort by dependency depth to ensure correct update order\n                computations.sort((a, b) => a.getDepth() - b.getDepth());\n\n                for (const computation of computations) {\n                    if (computation.isDirty() && !computation.isDisposed()) {\n                        computation.recompute();\n                    }\n                }\n            }\n        } finally {\n            this.processing = false;\n            this.updateDepth--;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, type WritableSignal } from './interfaces';\nimport { UpdateQueue } from './updateQueue';\n\n/**\n * Base class for managing reactive computations\n */\nexport abstract class Computation implements Disposable, IComputation {\n    protected dirty = true;\n    protected disposed = false;\n    protected dependencies = new Set<WritableSignal<any>>();\n    protected dependents = new Set<Computation>();\n    protected depth = 0;\n    protected name?: string;\n\n    abstract recompute(): void;\n\n    constructor(name?: string) {\n        this.name = name;\n    }\n\n\n    /**\n     * Add a dependency to this computation\n     */\n    addDependency(signal: WritableSignal<any>): void {\n        if (!this.dependencies.has(signal)) {\n            this.dependencies.add(signal);\n            if (signal.constructor.name == 'ComputedSignal') {\n                this.updateDepth();\n            }\n        }\n    }\n\n    /**\n     * Remove a dependency from this computation\n     */\n    removeDependency(signal: WritableSignal<any>): void {\n        if (this.dependencies.delete(signal)) {\n            this.updateDepth();\n        }\n    }\n\n    /**\n     * Clean up computation resources\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        this.clearDependencies();\n        this.dependents.clear();\n    }\n\n    /**\n     * Check if computation is dirty\n     */\n    isDirty(): boolean {\n        return this.dirty;\n    }\n\n    /**\n     * Check if computation has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Add a dependent computation, which will be recomputed when this computation updates\n     */\n    getDepth(): number {\n        return this.depth;\n    }\n\n    /**\n     * Mark computation as dirty and schedule update\n     */\n    markDirty(): void {\n\n        if (!this.disposed) {\n            this.dirty = true;\n            UpdateQueue.getInstance().schedule(this);\n        }\n    }\n\n    /**\n     * Check if signal is a dependency of this computation\n     * @param signal\n     */\n    hasSignal(signal: WritableSignal<any>): boolean {\n        return this.dependencies.has(signal);\n    }\n\n    /**\n     * Clear all dependencies and update depth\n     */\n    clearDependencies(): void {\n        for (const dep of this.dependencies) {\n            dep.removeDependent(this);\n        }\n        this.dependencies.clear();\n        this.updateDepth();\n    }\n\n    /**\n     * Update the computation's depth in the dependency graph\n     */\n    updateDepth(): void {\n        const oldDepth = this.depth;\n        let maxDepth = 0;\n\n        for (const dep of this.dependencies) {\n            if (dep.constructor.name == 'ComputedSignal') {\n                // @ts-ignore TODO use concrete type\n                maxDepth = Math.max(maxDepth, dep.getDepth() + 1);\n            }\n        }\n\n        if (oldDepth !== maxDepth) {\n            this.depth = maxDepth;\n            // Propagate depth update to dependents\n            for (const dependent of this.dependents) {\n                dependent.updateDepth();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable, IComputation, IEffect, WritableSignal } from './interfaces';\n\n/**\n * Manages the global state and context of signal computations\n */\nexport class Context {\n    private static instance: Context;\n    private computationStack: IComputation[] = [];\n    private batchDepth = 0;\n    private batchQueue = new Set<WritableSignal<any>>();\n    private activeEffects = new Set<Disposable>();\n\n    static getInstance(): Context {\n        if (!this.instance) {\n            this.instance = new Context();\n        }\n        return this.instance;\n    }\n\n    getCurrentComputation(): IComputation | undefined {\n        return this.computationStack[this.computationStack.length - 1];\n    }\n\n    pushComputation(computation: IComputation): void {\n        // Check for circular dependencies\n        if (computation && this.computationStack.includes(computation)) {\n            // throw new CircularDependencyError();\n            return;\n        }\n        // we can push undefined to the stack\n        this.computationStack.push(computation);\n    }\n\n    popComputation(): void {\n        this.computationStack.pop();\n    }\n\n    isBatching(): boolean {\n        return this.batchDepth > 0;\n    }\n\n    beginBatch(): void {\n        this.batchDepth++;\n    }\n\n    endBatch(): void {\n        this.batchDepth--;\n        if (this.batchDepth === 0) {\n            this.flushBatchQueue();\n        }\n    }\n\n    addToBatchQueue(signal: WritableSignal<any>): void {\n        this.batchQueue.add(signal);\n    }\n\n    flushBatchQueue(): void {\n        // Create a new Set for unique signals\n        const uniqueSignals = new Set(this.batchQueue);\n        this.batchQueue.clear();\n\n        // Get all dependent computations\n        const computations = new Set<IComputation>();\n\n        for (const signal of uniqueSignals) {\n            for (const dependent of signal.getDependents()) {\n                computations.add(dependent);\n            }\n        }\n        // Mark all computations as dirty\n        for (const computation of computations) {\n            computation.markDirty();\n        }\n    }\n\n    setCurrentComputation(computation: IComputation): void {\n        this.computationStack[this.computationStack.length - 1] = computation;\n    }\n\n\n    registerEffect(effect: IEffect): void {\n        this.activeEffects.add(effect);\n    }\n\n    unregisterEffect(effect: IEffect): void {\n        this.activeEffects.delete(effect);\n    }\n\n    // Add this method to check if we're currently in an effect\n    isInEffect(): boolean {\n        return this.activeEffects.size > 0;\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Disposed signal operations\n */\nexport class SignalDisposedError extends Error {\n    constructor(operation: string) {\n        super(`Cannot ${operation} a disposed signal`);\n        this.name = 'SignalDisposedError';\n    }\n}\n\n/**\n * Circular dependency detection\n */\nexport class CircularDependencyError extends Error {\n    constructor(signalName?: string) {\n        super(`Circular dependency detected${signalName ? ` in signal \"${signalName}\"` : ''}`);\n        this.name = 'CircularDependencyError';\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { IComputation, SignalOptions, WritableSignal } from './interfaces';\nimport { SignalDisposedError } from './errors';\nimport { EqualityFunction, TransformFunction } from './types';\nimport { Context } from './context';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Base<T> implements WritableSignal<T> {\n    /**\n     * Function to compare previous and next values for equality.\n     * Used to determine if dependents should be notified of changes.\n     */\n    equals: EqualityFunction<T>;\n    /**\n     * Optional name for debugging and identification purposes\n     */\n    name?: string;\n    /**\n     * Set of computations that depend on this signal's value\n     */\n    protected dependents = new Set<IComputation>();\n\n    /**\n     * Flag indicating whether this signal has been disposed\n     */\n    protected disposed = false;\n\n    /**\n     * Creates a new Signal instance\n     *\n     * @param initialValue - The initial value of the signal\n     * @param options - Configuration options for the signal\n     */\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        this._value = initialValue as T;\n        // Use provided equals function or default to Object.is\n        this.equals = options.equals ?? Object.is;\n        this.name = options.name || 'anonymous';\n    }\n\n    isCommutable(): boolean {\n        throw new Error('Method not implemented.');\n    }\n\n    /**\n     * The current value stored in the signal\n     */\n    protected _value: T;\n\n    /**\n     * Gets the current value of the signal.\n     * Tracks dependencies and throws if the signal is disposed.\n     */\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Sets a new value for the signal.\n     * Only updates and notifies dependents if the new value is different from the current value.\n     *\n     * @param newValue - The new value to set\n     */\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('write to');\n        }\n        if (!this.equals(this._value, newValue)) {\n            this._value = newValue;\n            this.notifyDependents();\n        }\n    }\n\n    /**\n     * Gets the current value of the signal without tracking dependencies.\n     */\n    get_value_bypass_tracking(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n        return this._value;\n    }\n\n    /**\n     * Updates the signal's value using a transformation function\n     *\n     * @param fn - Function that takes the current value and returns a new value\n     */\n    update(fn: TransformFunction<T>): void {\n        this.value = fn(this._value);\n    }\n\n\n    /**\n     * Adds a computation as dependent on this signal\n     *\n     * @param computation - The computation to add as a dependent\n     */\n    addDependent(computation: IComputation): void {\n        this.dependents.add(computation);\n    }\n\n    /**\n     * Removes a computation from this signal's dependents\n     *\n     * @param computation - The computation to remove\n     */\n    removeDependent(computation: IComputation): void {\n        this.dependents.delete(computation);\n    }\n\n    /**\n     * Notifies all dependent computations of a value change\n     * Handles batching through SignalContext if active\n     */\n    notifyDependents(): void {\n        const context = Context.getInstance();\n\n        if (context.isBatching()) {\n            context.addToBatchQueue(this);\n            return;\n        }\n\n        for (const dependent of this.dependents) {\n            dependent.markDirty();\n        }\n    }\n\n    /**\n     * Disposes of the signal and its dependent computations\n     * Prevents memory leaks by cleaning up all references\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n\n        // Create a copy of dependents before iterating to avoid modification during iteration\n        const dependentsToDispose = new Set(this.dependents);\n\n        // First, clear own dependents\n        this.dependents.clear();\n\n        // Then dispose all dependent computations\n        for (const dependent of dependentsToDispose) {\n            // @ts-ignore TODO use concrete type\n            if (dependent.constructor.name == 'ComputedSignal'  || dependent['signal']?.constructor.name == 'ComputedSignal') {\n                // If the dependent is or belongs to a ComputedSignal, dispose it\n                // @ts-ignore\n                const signal = dependent.constructor.name == 'ComputedSignal' ? dependent : dependent['signal'];\n                signal.dispose();\n            } else {\n                // For other types of computations, just dispose the computation\n                dependent.dispose();\n            }\n        }\n    }\n\n    /**\n     * Returns whether the signal has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    getDependents(): Set<IComputation> {\n        return this.dependents || new Set();\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    hasDependents(): boolean {\n        return this.dependents.size > 0;\n    }\n\n    toString(): string {\n        return `Signal(${this.name})`;\n    }\n\n    /**\n     * Tracks the current computation as dependent on this signal\n     */\n    protected trackDependency(): void {\n        const computation = Context.getInstance().getCurrentComputation();\n        if (computation) {\n            computation.addDependency(this);\n            this.addDependent(computation);\n        }\n    }\n}\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Context } from './context';\nimport { Computation } from './computation';\n\nexport class SubscriptionComputation extends Computation {\n    constructor(\n        private callback: () => void\n    ) {\n        super('subscription');\n    }\n\n    recompute(): void {\n        if (this.disposed) return;\n        const context = Context.getInstance();\n        const prevComputation = context.getCurrentComputation();\n        context.setCurrentComputation(this);\n\n        try {\n            this.callback();\n        } finally {\n            if (prevComputation) {\n                context.setCurrentComputation(prevComputation);\n            }\n            this.dirty = false;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Core imports for the Signal implementation\n */\nimport { SignalOptions } from './interfaces';\nimport { UnsubscribeFunction } from './types';\nimport { Base } from './base';\nimport { SignalDisposedError } from './errors';\nimport { SubscriptionComputation } from './SubscriptionComputation';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Signal<T> extends Base<T> {\n\n    constructor(initialValue?: T, options: SignalOptions<T> = {}) {\n        super(initialValue, options);\n    }\n\n    /**\n     * Creates a subscription to the signal's value changes\n     *\n     * @param callback - Function to call when the value changes\n     * @returns Function to unsubscribe from changes\n     */\n    subscribe(callback: (value: T) => void): UnsubscribeFunction {\n        if (this.disposed) {\n            throw new SignalDisposedError('subscribe to');\n        }\n        const computed = new SubscriptionComputation(() => {\n            return callback(this.value);\n        });\n\n        computed.recompute();\n\n        return () => computed.dispose();\n    }\n }\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\nimport { Computation } from './computation';\nimport { Context } from './context';\nimport { Signal } from './signal';\nimport type { SignalOptions, WritableSignal } from './interfaces';\nimport { CircularDependencyError, SignalDisposedError } from './errors';\n\n/**\n * Signal that derives its value from other signals\n *\n * @example\n * // Create base signals\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n * // Create a computed signal that depends on firstName and lastName\n * const fullName = new ComputedSignal(() => {\n *   return `${firstName.value} ${lastName.value}`;\n * });\n *\n * console.log(fullName.value); // Output: \"John Doe\"\n *\n * // When a dependency changes, the computed value updates automatically\n * firstName.value = 'Jane';\n * console.log(fullName.value); // Output: \"Jane Doe\"\n */\nexport class ComputedSignal<T> extends Signal<T> {\n\n    /** Internal computation instance to manage dependencies and recomputation */\n    private readonly computation: Computation;\n\n    /** Function that computes the derived value */\n    private computeFn: () => T;\n\n    /**\n     * Creates a new computed signal\n     * @param compute Function that derives the signal value\n     * @param options Configuration options for the signal\n     */\n    constructor(compute: () => T, options: SignalOptions<T> = {}) {\n        super({} as T, options);\n        this.computeFn = compute;\n\n        // Create an anonymous computation class instance\n        this.computation = new class ComputationA extends Computation {\n            constructor(private signal: ComputedSignal<T>) {\n                super();\n            }\n\n            /**\n             * Recomputes the signal value when dependencies change\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = Context.getInstance();\n                const prevComputation = context.getCurrentComputation();\n                context.setCurrentComputation(this);\n\n                // Prevent circular dependencies through effects\n                if (context.isInEffect()) {\n                    throw new CircularDependencyError(\n                        `Cannot create computed signal that depends on effects`,\n                    );\n                }\n\n                try {\n                    // Check if any dependencies have been disposed\n                    for (const dep of this.dependencies) {\n                        if (dep.isDisposed()) {\n                            this.signal.dispose();\n                            throw new SignalDisposedError('read from disposed dependency');\n                        }\n                    }\n\n                    // Compute new value and update if changed\n                    const newValue = this.signal.computeFn();\n                    if (!this.signal.equals(this.signal._value, newValue)) {\n                        this.signal._value = newValue;\n                        this.signal.notifyDependents();\n                    }\n                } catch (error) {\n                    // Handle disposal errors\n                    if (error instanceof SignalDisposedError) {\n                        this.signal.dispose();\n                    }\n                    throw error;\n                } finally {\n                    // Restore previous computation context\n                    if (prevComputation) {\n                        context.setCurrentComputation(prevComputation);\n                    }\n                    this.dirty = false;\n                }\n            }\n        }(this);\n        // Initial computation\n        this.computation.recompute();\n\n    }\n\n    /**\n     * Gets the current value of the computed signal\n     */\n    override get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        // Verify dependencies are still valid\n        const dependencies = this.computation['dependencies'] as Set<WritableSignal<any>>;\n        for (const dep of dependencies) {\n            if (dep.isDisposed()) {\n                this.dispose();\n                throw new SignalDisposedError('read from disposed dependency');\n            }\n        }\n\n        // Recompute if dependencies have changed\n        if (this.computation.isDirty()) {\n            this.computation.recompute();\n        }\n\n        // Track this signal as a dependency for other computations\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Computed signals cannot be set directly\n     */\n    override set value(_: T) {\n        throw new Error('Cannot set the value of a computed signal');\n    }\n\n    /**\n     * Gets the depth of this signal in the dependency graph\n     */\n    getDepth(): number {\n        return this.computation.getDepth();\n    }\n\n    /**\n     * Cleans up the signal and its dependencies\n     */\n    override dispose(): void {\n        if (this.disposed) return;\n\n        super.dispose();\n        this.computation.dispose();\n\n        // Recursively dispose dependent computed signals\n        for (const dependent of this.dependents) {\n            // @ts-ignore\n            if (dependent instanceof ComputedSignal || dependent['signal'] instanceof ComputedSignal) {\n                // @ts-ignore\n                const signal = dependent instanceof ComputedSignal ? dependent : dependent['signal'];\n                signal.dispose();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport { ComputedSignal } from './computedSignal';\nimport type { SignalOptions } from './interfaces';\n\n\n\n/**\n * Create a computed signal that derives its value from other signals\n */\nexport function computed<T>(\n    compute: () => T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new ComputedSignal(compute, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal, SignalOptions } from '../core';\nimport { computed } from '../core/computed';\n\n/**\n * Combines multiple signals into a single signal containing an array of their values.\n * When any of the input signals change, the combined signal updates with all current values.\n *\n * @template T - Tuple type representing the types of values from each input signal\n *\n * @param signals - An array of signals to combine. Each signal can have a different type,\n *                 represented by the corresponding type in the tuple T.\n * @param options - Optional configuration options for the resulting signal, including\n *                 custom equality comparison and naming.\n *\n * @returns A new signal containing an array of the current values from all input signals.\n *          The returned signal updates whenever any input signal changes.\n *\n * @example\n * // Combining signals of different types\n * const nameSignal = new Signal<string>('John');\n * const ageSignal = new Signal<number>(25);\n * const activeSignal = new Signal<boolean>(true);\n *\n * const combined = combine([nameSignal, ageSignal, activeSignal]);\n * console.log(combined.value); // ['John', 25, true]\n *\n * nameSignal.value = 'Jane';\n * console.log(combined.value); // ['Jane', 25, true]\n *\n * @example\n * // Using with custom equality function\n * const combined = combine([sig1, sig2], {\n *   equals: (prev, next) =>\n *     prev.length === next.length &&\n *     prev.every((val, idx) => Object.is(val, next[idx]))\n * });\n */\nexport function combine<T extends any[]>(\n    signals: { [K in keyof T]: Signal<T[K]> },\n    options?: SignalOptions<T>,\n): Signal<T> {\n    // dependencies on all input signals through their .value accessors\n    return computed(() => (signals.map(s => s.value) as T), {\n        // Ensure updates are propagated by using appropriate equality check\n        equals: options?.equals ?? ((prev, next) => {\n            if (!prev || !next || prev.length !== next.length) return false;\n            return prev.every((val, idx) => Object.is(val, next[idx]));\n        }),\n        name: options?.name || `Signal(combine)[${signals.map(s => s.toString()).join(', ')}]`,\n    });\n\n\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","UpdateQueue","queue","Set","processing","updateDepth","maxUpdateDepth","getInstance","instance","schedule","computation","Error","add","processQueue","size","computations","Array","from","clear","sort","a","b","getDepth","isDirty","isDisposed","recompute","Computation","constructor","name","dirty","disposed","dependencies","dependents","depth","addDependency","signal","has","removeDependency","delete","dispose","clearDependencies","markDirty","hasSignal","dep","removeDependent","oldDepth","maxDepth","Math","max","dependent","Context","computationStack","batchDepth","batchQueue","activeEffects","getCurrentComputation","length","pushComputation","includes","push","popComputation","pop","isBatching","beginBatch","endBatch","flushBatchQueue","addToBatchQueue","uniqueSignals","getDependents","setCurrentComputation","registerEffect","effect","unregisterEffect","isInEffect","SignalDisposedError","operation","super","CircularDependencyError","signalName","Base","initialValue","options","_value","equals","is","isCommutable","trackDependency","newValue","notifyDependents","get_value_bypass_tracking","update","fn","addDependent","context","dependentsToDispose","hasDependents","toString","SubscriptionComputation","callback","prevComputation","Signal","subscribe","computed","ComputedSignal","compute","computeFn","error","_","combine","signals","map","s","prev","next","every","val","idx","join"],"sourceRoot":""}