{"version":3,"file":"index.umd.min.js","mappings":"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","sources":["webpack://Avati/webpack/universalModuleDefinition","webpack://Avati/webpack/bootstrap","webpack://Avati/webpack/runtime/define property getters","webpack://Avati/webpack/runtime/hasOwnProperty shorthand","webpack://Avati/webpack/runtime/make namespace object","webpack://Avati/./src/signalContext.ts","webpack://Avati/./src/batch.ts","webpack://Avati/./src/updateQueue.ts","webpack://Avati/./src/computation.ts","webpack://Avati/./src/errors.ts","webpack://Avati/./src/signal.ts","webpack://Avati/./src/computedSignal.ts","webpack://Avati/./src/computed.ts","webpack://Avati/./src/combine.ts","webpack://Avati/./src/signalMonitor.ts","webpack://Avati/./src/createSignal.ts","webpack://Avati/./src/validated.ts","webpack://Avati/./src/map.ts","webpack://Avati/./src/effect.ts","webpack://Avati/./src/debounced.ts","webpack://Avati/./src/filtered.ts","webpack://Avati/./src/debug.ts","webpack://Avati/./src/peek.ts","webpack://Avati/./src/threshold.ts","webpack://Avati/./src/utility.ts","webpack://Avati/./src/withHistory.ts","webpack://Avati/./src/throttled.ts","webpack://Avati/./src/persisted.ts","webpack://Avati/./src/asyncSignal.ts","webpack://Avati/./src/queue.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Avati\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Avati\"] = factory();\n\telse\n\t\troot[\"Avati\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Computation } from './computation';\nimport { Signal } from './signal';\nimport { EffectImpl } from './effect';\n\n/**\n * Manages the global state and context of signal computations\n */\nexport class SignalContext {\n    private static instance: SignalContext;\n    private computationStack: Computation[] = [];\n    private batchDepth = 0;\n    private batchQueue = new Set<Signal<any>>();\n    private activeEffects = new Set<EffectImpl>();\n\n    static getInstance(): SignalContext {\n        if (!this.instance) {\n            this.instance = new SignalContext();\n        }\n        return this.instance;\n    }\n\n    getCurrentComputation(): Computation | undefined {\n        return this.computationStack[this.computationStack.length - 1];\n    }\n\n    pushComputation(computation: Computation): void {\n        // Check for circular dependencies\n        if (computation && this.computationStack.includes(computation)) {\n            // throw new CircularDependencyError();\n            return;\n        }\n        // we can push undefined to the stack\n        this.computationStack.push(computation);\n    }\n\n    popComputation(): void {\n        this.computationStack.pop();\n    }\n\n    isBatching(): boolean {\n        return this.batchDepth > 0;\n    }\n\n    beginBatch(): void {\n        this.batchDepth++;\n    }\n\n    endBatch(): void {\n        this.batchDepth--;\n        if (this.batchDepth === 0) {\n            this.flushBatchQueue();\n        }\n    }\n\n    addToBatchQueue(signal: Signal<any>): void {\n        this.batchQueue.add(signal);\n    }\n\n    flushBatchQueue(): void {\n        // Create a new Set for unique signals\n        const uniqueSignals = new Set(this.batchQueue);\n        this.batchQueue.clear();\n\n        // Get all dependent computations\n        const computations = new Set<Computation>();\n\n        for (const signal of uniqueSignals) {\n            for (const dependent of signal.getDependents()) {\n                computations.add(dependent);\n            }\n        }\n        // Mark all computations as dirty\n        for (const computation of computations) {\n            computation.markDirty();\n        }\n    }\n\n    setCurrentComputation(computation: Computation): void {\n        this.computationStack[this.computationStack.length - 1] = computation;\n    }\n\n\n    registerEffect(effect: EffectImpl): void {\n        this.activeEffects.add(effect);\n    }\n\n    unregisterEffect(effect: EffectImpl): void {\n        this.activeEffects.delete(effect);\n    }\n\n    // Add this method to check if we're currently in an effect\n    isInEffect(): boolean {\n        return this.activeEffects.size > 0;\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { SignalContext } from './signalContext';\n\n/**\n * Batch multiple signal updates to prevent cascading updates\n */\nexport function batch<T>(fn: () => T): T {\n    const context = SignalContext.getInstance();\n    context.beginBatch();\n    try {\n        return fn();\n    } finally {\n        context.endBatch();\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Computation } from './computation';\n\n/**\n * Manages the scheduling and processing of signal updates\n * Uses a topological sort to handle updates in the correct order\n */\nexport class UpdateQueue {\n    private static instance: UpdateQueue;\n    private queue = new Set<Computation>();\n    private processing = false;\n    private updateDepth = 0;\n    private maxUpdateDepth = 1000; // Configurable maximum update depth\n\n    static getInstance(): UpdateQueue {\n        if (!this.instance) {\n            this.instance = new UpdateQueue();\n        }\n        return this.instance;\n    }\n\n    /**\n     * Schedule a computation for update\n     */\n    schedule(computation: Computation): void {\n        if (this.updateDepth >= this.maxUpdateDepth) {\n            throw new Error('Maximum update depth exceeded - possible circular dependency');\n        }\n\n        this.queue.add(computation);\n        if (!this.processing) {\n            this.processQueue();\n        }\n    }\n\n    /**\n     * Process all scheduled updates in dependency order\n     */\n    private processQueue(): void {\n        this.processing = true;\n        this.updateDepth++;\n\n        try {\n            while (this.queue.size > 0) {\n                const computations = Array.from(this.queue);\n                this.queue.clear();\n\n                // Sort by dependency depth to ensure correct update order\n                computations.sort((a, b) => a.getDepth() - b.getDepth());\n\n                for (const computation of computations) {\n                    if (computation.isDirty() && !computation.isDisposed()) {\n                        computation.recompute();\n                    }\n                }\n            }\n        } finally {\n            this.processing = false;\n            this.updateDepth--;\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Disposable } from './interfaces';\nimport { Signal } from './signal';\nimport { ComputedSignal } from './computedSignal';\nimport { UpdateQueue } from './updateQueue';\n\n/**\n * Base class for managing reactive computations\n */\nexport abstract class Computation implements Disposable {\n    protected dirty = true;\n    protected disposed = false;\n    protected dependencies = new Set<Signal<any>>();\n    protected dependents = new Set<Computation>();\n    protected depth = 0;\n    protected name?: string;\n\n    constructor(name?: string) {\n        this.name = name;\n    }\n\n    abstract recompute(): void;\n\n\n    /**\n     * Add a dependency to this computation\n     */\n    addDependency(signal: Signal<any>): void {\n        if (!this.dependencies.has(signal)) {\n            this.dependencies.add(signal);\n            if (signal instanceof ComputedSignal) {\n                this.updateDepth();\n            }\n        }\n    }\n\n    /**\n     * Remove a dependency from this computation\n     */\n    removeDependency(signal: Signal<any>): void {\n        if (this.dependencies.delete(signal)) {\n            this.updateDepth();\n        }\n    }\n\n    /**\n     * Clean up computation resources\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        this.clearDependencies();\n        this.dependents.clear();\n    }\n\n    /**\n     * Check if computation is dirty\n     */\n    isDirty(): boolean {\n        return this.dirty;\n    }\n\n    /**\n     * Check if computation has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Add a dependent computation, which will be recomputed when this computation updates\n     */\n    getDepth(): number {\n        return this.depth;\n    }\n\n    /**\n     * Mark computation as dirty and schedule update\n     */\n    markDirty(): void {\n\n        if (!this.disposed) {\n            this.dirty = true;\n            UpdateQueue.getInstance().schedule(this);\n        }\n    }\n\n    /**\n     * Check if signal is a dependency of this computation\n     * @param signal\n     */\n    hasSignal(signal: Signal<any>): boolean {\n        return this.dependencies.has(signal);\n    }\n\n    /**\n     * Clear all dependencies and update depth\n     */\n    protected clearDependencies(): void {\n        for (const dep of this.dependencies) {\n            dep.removeDependent(this);\n        }\n        this.dependencies.clear();\n        this.updateDepth();\n    }\n\n    /**\n     * Update the computation's depth in the dependency graph\n     */\n    protected updateDepth(): void {\n        const oldDepth = this.depth;\n        let maxDepth = 0;\n\n        for (const dep of this.dependencies) {\n            if (dep instanceof ComputedSignal) {\n                maxDepth = Math.max(maxDepth, dep.getDepth() + 1);\n            }\n        }\n\n        if (oldDepth !== maxDepth) {\n            this.depth = maxDepth;\n            // Propagate depth update to dependents\n            for (const dependent of this.dependents) {\n                dependent.updateDepth();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Disposed signal operations\n */\nexport class SignalDisposedError extends Error {\n    constructor(operation: string) {\n        super(`Cannot ${operation} a disposed signal`);\n        this.name = 'SignalDisposedError';\n    }\n}\n\n/**\n * Circular dependency detection\n */\nexport class CircularDependencyError extends Error {\n    constructor(signalName?: string) {\n        super(`Circular dependency detected${signalName ? ` in signal \"${signalName}\"` : ''}`);\n        this.name = 'CircularDependencyError';\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\n/**\n * Core imports for the Signal implementation\n */\nimport { SignalOptions, WritableSignal } from './interfaces';\nimport { Computation } from './computation';\nimport { ComputedSignal } from './computedSignal';\nimport { SignalDisposedError } from './errors';\nimport { EqualityFunction, TransformFunction, UnsubscribeFunction } from './types';\nimport { SignalContext } from './signalContext';\n\n/**\n * Signal class implements a reactive primitive that holds a value and notifies dependents of changes.\n * It follows the WritableSignal interface contract for value updates and subscriptions.\n *\n * @template T The type of value held by the signal\n\n *\n * @example\n * // Basic usage with primitive values\n * const counter = new Signal(0);\n * console.log(counter.value); // 0\n * counter.value = 1;\n * console.log(counter.value); // 1\n *\n * @example\n * // Using update function\n * const counter = new Signal(0);\n * counter.update(current => current + 1); // Increments by 1\n *\n * @example\n * // Subscribing to changes\n * const name = new Signal('John');\n * const unsubscribe = name.subscribe(newValue => {\n *   console.log(`Name changed to: ${newValue}`);\n * });\n * name.value = 'Jane'; // Logs: \"Name changed to: Jane\"\n * unsubscribe(); // Removes the subscription\n *\n * @example\n * // Using custom equality function for objects\n * const user = new Signal(\n *   { id: 1, name: 'John' },\n *   {\n *     equals: (prev, next) => prev.id === next.id && prev.name === next.name\n *   }\n * );\n *\n * @example\n * // Proper cleanup\n * const signal = new Signal('test');\n * // ... use signal\n * signal.dispose(); // Clean up when done\n *\n * @example\n * // Using with arrays\n * const list = new Signal<number[]>([]);\n * list.update(current => [...current, 1]); // Adds element\n * list.update(current => current.filter(x => x > 0)); // Filters elements\n *\n * @example\n * // Error handling\n * try {\n *   const signal = new Signal('test');\n *   signal.dispose();\n *   signal.value; // Throws SignalDisposedError\n * } catch (error) {\n *   if (error instanceof SignalDisposedError) {\n *     console.log('Signal was disposed');\n *   }\n * }\n *\n * @example\n * // Using with complex objects and custom name\n * interface Todo {\n *   id: number;\n *   text: string;\n *   completed: boolean;\n * }\n *\n * const todos = new Signal<Todo[]>(\n *   [],\n *   {\n *     name: 'todosList',\n *     equals: (prev, next) =>\n *       prev.length === next.length &&\n *       prev.every((todo, index) =>\n *         todo.id === next[index].id &&\n *         todo.text === next[index].text &&\n *         todo.completed === next[index].completed\n *       )\n *   }\n * );\n *\n * @example\n * // Batching updates using SignalContext\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n */\nexport class Signal<T> implements WritableSignal<T> {\n    /**\n     * Function to compare previous and next values for equality.\n     * Used to determine if dependents should be notified of changes.\n     */\n    equals: EqualityFunction<T>;\n    /**\n     * Optional name for debugging and identification purposes\n     */\n    name?: string;\n    /**\n     * Set of computations that depend on this signal's value\n     */\n    protected dependents = new Set<Computation>();\n\n    /**\n     * Flag indicating whether this signal has been disposed\n     */\n    protected disposed = false;\n\n    /**\n     * Creates a new Signal instance\n     *\n     * @param initialValue - The initial value of the signal\n     * @param options - Configuration options for the signal\n     */\n    constructor(initialValue: T, options: SignalOptions<T> = {}) {\n        this._value = initialValue;\n        // Use provided equals function or default to Object.is\n        this.equals = options.equals ?? Object.is;\n        this.name = options.name || 'anonymous';\n    }\n\n    /**\n     * The current value stored in the signal\n     */\n    protected _value: T;\n\n    /**\n     * Gets the current value of the signal.\n     * Tracks dependencies and throws if the signal is disposed.\n     */\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Sets a new value for the signal.\n     * Only updates and notifies dependents if the new value is different from the current value.\n     *\n     * @param newValue - The new value to set\n     */\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('write to');\n        }\n        if (!this.equals(this._value, newValue)) {\n            this._value = newValue;\n            this.notifyDependents();\n        }\n    }\n\n    /**\n     * Gets the current value of the signal without tracking dependencies.\n     */\n    get_value_bypass_tracking(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n        return this._value;\n    }\n\n    /**\n     * Updates the signal's value using a transformation function\n     *\n     * @param fn - Function that takes the current value and returns a new value\n     */\n    update(fn: TransformFunction<T>): void {\n        this.value = fn(this._value);\n    }\n\n    /**\n     * Creates a subscription to the signal's value changes\n     *\n     * @param callback - Function to call when the value changes\n     * @returns Function to unsubscribe from changes\n     */\n    subscribe(callback: (value: T) => void): UnsubscribeFunction {\n        if (this.disposed) {\n            throw new SignalDisposedError('subscribe to');\n        }\n        const computed = new ComputedSignal(() => {\n            return callback(this.value);\n        });\n\n        return () => computed.dispose();\n    }\n\n    /**\n     * Adds a computation as dependent on this signal\n     *\n     * @param computation - The computation to add as a dependent\n     */\n    addDependent(computation: Computation): void {\n        this.dependents.add(computation);\n    }\n\n    /**\n     * Removes a computation from this signal's dependents\n     *\n     * @param computation - The computation to remove\n     */\n    removeDependent(computation: Computation): void {\n        this.dependents.delete(computation);\n    }\n\n    /**\n     * Notifies all dependent computations of a value change\n     * Handles batching through SignalContext if active\n     */\n    notifyDependents(): void {\n        const context = SignalContext.getInstance();\n\n        if (context.isBatching()) {\n            context.addToBatchQueue(this);\n            return;\n        }\n\n        for (const dependent of this.dependents) {\n            dependent.markDirty();\n        }\n    }\n\n    /**\n     * Disposes of the signal and its dependent computations\n     * Prevents memory leaks by cleaning up all references\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n\n        // Create a copy of dependents before iterating to avoid modification during iteration\n        const dependentsToDispose = new Set(this.dependents);\n\n        // First, clear own dependents\n        this.dependents.clear();\n\n        // Then dispose all dependent computations\n        for (const dependent of dependentsToDispose) {\n            // @ts-ignore\n            if (dependent instanceof ComputedSignal || dependent['signal'] instanceof ComputedSignal) {\n                // If the dependent is or belongs to a ComputedSignal, dispose it\n                // @ts-ignore\n                const signal = dependent instanceof ComputedSignal ? dependent : dependent['signal'];\n                signal.dispose();\n            } else {\n                // For other types of computations, just dispose the computation\n                dependent.dispose();\n            }\n        }\n    }\n\n    /**\n     * Returns whether the signal has been disposed\n     */\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    getDependents(): Set<Computation> {\n        return this.dependents || new Set();\n    }\n\n    /**\n     * Returns the name of the signal for debugging purposes\n     */\n    hasDependents(): boolean {\n        return this.dependents.size > 0;\n    }\n\n    toString(): string {\n        return `Signal(${this.name})`;\n    }\n\n    /**\n     * Tracks the current computation as dependent on this signal\n     */\n    protected trackDependency(): void {\n        const computation = SignalContext.getInstance().getCurrentComputation();\n        if (computation) {\n            computation.addDependency(this);\n            this.addDependent(computation);\n        }\n    }\n}\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\nimport { Computation } from './computation';\nimport { SignalOptions } from './interfaces';\nimport { SignalContext } from './signalContext';\nimport { Signal } from './signal';\nimport { CircularDependencyError, SignalDisposedError } from './errors';\n\n/**\n * Signal that derives its value from other signals\n *\n * @example\n * // Create base signals\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n *\n * // Create a computed signal that depends on firstName and lastName\n * const fullName = new ComputedSignal(() => {\n *   return `${firstName.value} ${lastName.value}`;\n * });\n *\n * console.log(fullName.value); // Output: \"John Doe\"\n *\n * // When a dependency changes, the computed value updates automatically\n * firstName.value = 'Jane';\n * console.log(fullName.value); // Output: \"Jane Doe\"\n */\nexport class ComputedSignal<T> extends Signal<T> {\n\n    /** Internal computation instance to manage dependencies and recomputation */\n    private readonly computation: Computation;\n\n    /** Function that computes the derived value */\n    private computeFn: () => T;\n\n    /**\n     * Creates a new computed signal\n     * @param compute Function that derives the signal value\n     * @param options Configuration options for the signal\n     */\n    constructor(compute: () => T, options: SignalOptions<T> = {}) {\n        super(undefined as T, options);\n        this.computeFn = compute;\n\n        // Create an anonymous computation class instance\n        this.computation = new class extends Computation {\n            constructor(private signal: ComputedSignal<T>) {\n                super(signal.name);\n            }\n\n            /**\n             * Recomputes the signal value when dependencies change\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = SignalContext.getInstance();\n                const prevComputation = context.getCurrentComputation();\n                context.setCurrentComputation(this);\n\n                // Prevent circular dependencies through effects\n                if (context.isInEffect()) {\n                    throw new CircularDependencyError(\n                        `Cannot create computed signal that depends on effects`,\n                    );\n                }\n\n                try {\n                    // Check if any dependencies have been disposed\n                    for (const dep of this.dependencies) {\n                        if (dep.isDisposed()) {\n                            this.signal.dispose();\n                            throw new SignalDisposedError('read from disposed dependency');\n                        }\n                    }\n\n                    // Compute new value and update if changed\n                    const newValue = this.signal.computeFn();\n                    if (!this.signal.equals(this.signal._value, newValue)) {\n                        this.signal._value = newValue;\n                        this.signal.notifyDependents();\n                    }\n                } catch (error) {\n                    // Handle disposal errors\n                    if (error instanceof SignalDisposedError) {\n                        this.signal.dispose();\n                    }\n                    throw error;\n                } finally {\n                    // Restore previous computation context\n                    if (prevComputation) {\n                        context.setCurrentComputation(prevComputation);\n                    }\n                    this.dirty = false;\n                }\n            }\n        }(this);\n        // Initial computation\n        this.computation.recompute();\n\n    }\n\n    /**\n     * Gets the current value of the computed signal\n     */\n    override get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('read from');\n        }\n\n        // Verify dependencies are still valid\n        const dependencies = this.computation['dependencies'] as Set<Signal<any>>;\n        for (const dep of dependencies) {\n            if (dep.isDisposed()) {\n                this.dispose();\n                throw new SignalDisposedError('read from disposed dependency');\n            }\n        }\n\n        // Recompute if dependencies have changed\n        if (this.computation.isDirty()) {\n            this.computation.recompute();\n        }\n\n        // Track this signal as a dependency for other computations\n        this.trackDependency();\n        return this._value;\n    }\n\n    /**\n     * Computed signals cannot be set directly\n     */\n    override set value(_: T) {\n        throw new Error('Cannot set the value of a computed signal');\n    }\n\n    /**\n     * Gets the depth of this signal in the dependency graph\n     */\n    getDepth(): number {\n        return this.computation.getDepth();\n    }\n\n    /**\n     * Cleans up the signal and its dependencies\n     */\n    override dispose(): void {\n        if (this.disposed) return;\n\n        super.dispose();\n        this.computation.dispose();\n\n        // Recursively dispose dependent computed signals\n        for (const dependent of this.dependents) {\n            // @ts-ignore\n            if (dependent instanceof ComputedSignal || dependent['signal'] instanceof ComputedSignal) {\n                // @ts-ignore\n                const signal = dependent instanceof ComputedSignal ? dependent : dependent['signal'];\n                signal.dispose();\n            }\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { ComputedSignal } from './computedSignal';\nimport { Signal } from './signal';\n\n/**\n * Create a computed signal that derives its value from other signals\n */\nexport function computed<T>(\n    compute: () => T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new ComputedSignal(compute, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { Signal } from './signal';\nimport { computed } from './computed';\n\n/**\n * Combines multiple signals into a single signal containing an array of their values.\n * When any of the input signals change, the combined signal updates with all current values.\n *\n * @template T - Tuple type representing the types of values from each input signal\n *\n * @param signals - An array of signals to combine. Each signal can have a different type,\n *                 represented by the corresponding type in the tuple T.\n * @param options - Optional configuration options for the resulting signal, including\n *                 custom equality comparison and naming.\n *\n * @returns A new signal containing an array of the current values from all input signals.\n *          The returned signal updates whenever any input signal changes.\n *\n * @example\n * // Combining signals of different types\n * const nameSignal = new Signal<string>('John');\n * const ageSignal = new Signal<number>(25);\n * const activeSignal = new Signal<boolean>(true);\n *\n * const combined = combine([nameSignal, ageSignal, activeSignal]);\n * console.log(combined.value); // ['John', 25, true]\n *\n * nameSignal.value = 'Jane';\n * console.log(combined.value); // ['Jane', 25, true]\n *\n * @example\n * // Using with custom equality function\n * const combined = combine([sig1, sig2], {\n *   equals: (prev, next) =>\n *     prev.length === next.length &&\n *     prev.every((val, idx) => Object.is(val, next[idx]))\n * });\n */\nexport function combine<T extends any[]>(\n    signals: { [K in keyof T]: Signal<T[K]> },\n    options?: SignalOptions<T>,\n): Signal<T> {\n    // dependencies on all input signals through their .value accessors\n    return computed(() => (signals.map(s => s.value) as T), {\n        // Ensure updates are propagated by using appropriate equality check\n        equals: options?.equals ?? ((prev, next) => {\n            if (!prev || !next || prev.length !== next.length) return false;\n            return prev.every((val, idx) => Object.is(val, next[idx]));\n        }),\n        name: options?.name || `Signal(combine)[${signals.map(s => s.toString()).join(', ')}]`,\n    });\n\n\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { SignalMetrics } from './interfaces';\n\n/**\n * Monitor signal performance metrics\n */\nexport class SignalMonitor {\n    private static metrics: SignalMetrics = {\n        updates: 0,\n        computations: 0,\n        maxChainDepth: 0,\n        averageUpdateTime: 0,\n    };\n\n    private static updateTimes: number[] = [];\n\n    static trackUpdate(duration: number): void {\n        this.metrics.updates++;\n        this.updateTimes.push(duration);\n\n        if (this.updateTimes.length > 100) {\n            this.updateTimes.shift();\n        }\n\n        this.metrics.averageUpdateTime =\n            this.updateTimes.reduce((a, b) => a + b, 0) / this.updateTimes.length;\n    }\n\n    static trackComputation(depth: number): void {\n        this.metrics.computations++;\n        this.metrics.maxChainDepth = Math.max(this.metrics.maxChainDepth, depth);\n    }\n\n    static getMetrics(): SignalMetrics {\n        return { ...this.metrics };\n    }\n\n    static reset(): void {\n        this.metrics = {\n            updates: 0,\n            computations: 0,\n            maxChainDepth: 0,\n            averageUpdateTime: 0,\n        };\n        this.updateTimes = [];\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { Signal } from './signal';\n\n/**\n * Create a new writable signal\n */\nexport function createSignal<T>(\n    initialValue: T,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return new Signal(initialValue, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport { createSignal } from './createSignal';\nimport { SignalOptions } from './interfaces';\nimport { computed } from './computed';\n\n/**\n * Creates a Signal with validation capabilities.\n *\n * @template T - Type of value stored in the signal\n * @param initialValue - Starting value of the signal\n * @param validator - Function that validates new values before they're set\n * @param options - Standard SignalOptions configuration\n * @returns A Signal with validation logic applied to value updates\n *\n * @example\n * // Create a signal that only accepts positive numbers\n * const positiveNum = validated(1,\n *   (value) => value > 0 || \"Value must be positive\"\n * );\n *\n * @example\n * // Create a signal with complex validation and custom equality\n * const user = validated(\n *   { id: 1, name: \"John\" },\n *   (value) => {\n *     if (!value.name) return \"Name is required\";\n *     if (value.id < 0) return \"ID must be positive\";\n *     return true;\n *   },\n *   { equals: (a, b) => a.id === b.id }\n * );\n */\nexport function validated<T>(\n    initialValue: T,\n    validator: (value: T) => boolean | string,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const innerSignal = createSignal(initialValue, options);\n    const validationError = computed(() => {\n        const result = validator(innerSignal.value);\n        if (typeof result === 'string') return result;\n        if (!result) return 'Validation failed';\n        return null;\n    });\n\n    return new Proxy(innerSignal, {\n        get(target, prop) {\n            if (prop === 'value') {\n                const error = validationError.value;\n                if (error) throw new Error(error);\n                return target.value;\n            }\n            return target[prop as keyof typeof target];\n        },\n        set(target, prop, value) {\n            if (prop === 'value') {\n                const result = validator(value);\n                if (typeof result === 'string') throw new Error(result);\n                if (!result) throw new Error('Validation failed');\n                target.value = value;\n            }\n            return true;\n        },\n    });\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { computed } from './computed';\nimport { Signal } from './signal';\n\n/**\n * Creates a new Signal that transforms the value of a source Signal using a mapping function.\n * The resulting Signal updates automatically when the source Signal changes.\n *\n * @param source The input Signal to transform\n * @param transform Function that converts source value type T to output type U\n * @param options Optional configuration for the resulting Signal\n * @returns A new Signal containing the transformed value\n *\n *\n * @example\n * // Basic transformation of primitive values\n * const count = new Signal(5);\n * const doubled = map(count, n => n * 2);\n * console.log(doubled.value); // 10\n * count.value = 10;\n * console.log(doubled.value); // 20\n *\n * @example\n * // Transforming arrays\n * const numbers = new Signal([1, 2, 3]);\n * const doubled = map(numbers, nums => nums.map(n => n * 2));\n * console.log(doubled.value); // [2, 4, 6]\n *\n * @example\n * // Transforming objects with custom options\n * const user = new Signal({ name: 'John', age: 30 });\n * const userSummary = map(\n *   user,\n *   u => `${u.name} is ${u.age} years old`,\n *   { name: 'userSummary' }\n * );\n * console.log(userSummary.value); // \"John is 30 years old\"\n */\nexport function map<T, U>(\n    source: Signal<T>,\n    transform: (value: T) => U,\n    options?: SignalOptions<U>,\n): Signal<U> {\n    return computed(() => transform(source.value), options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Disposable } from './interfaces';\nimport { Computation } from './computation';\nimport { SignalContext } from './signalContext';\nimport { Cleanup, EffectFunction } from './types';\n\n\n/**\n * Implementation of reactive effects that automatically track and respond to signal changes.\n * Effects are used to perform side effects in response to reactive updates.\n *\n * @example\n * // Basic effect usage\n * const count = new Signal(0);\n * const dispose = effect(() => {\n *   console.log(`Count changed to: ${count.value}`);\n * });\n * count.value = 1; // Logs: \"Count changed to: 1\"\n * dispose(); // Cleanup effect\n *\n * @example\n * // Effect with cleanup\n * const visible = new Signal(true);\n * const dispose = effect(() => {\n *   if (visible.value) {\n *     const element = document.createElement('div');\n *     document.body.appendChild(element);\n *     // Return cleanup function\n *     return () => {\n *       document.body.removeChild(element);\n *     };\n *   }\n * });\n *\n * @example\n * // Named effect for debugging\n * const timer = new Signal(0);\n * const dispose = effect(() => {\n *   console.log(`Timer: ${timer.value}`);\n * }, 'timerLogger');\n *\n * @example\n * // Effect with multiple dependencies\n * const firstName = new Signal('John');\n * const lastName = new Signal('Doe');\n * const dispose = effect(() => {\n *   console.log(`Name changed to: ${firstName.value} ${lastName.value}`);\n * });\n *\n * @example\n * // Effect with error handling\n * const data = new Signal<string | Error>(null);\n * const dispose = effect(() => {\n *   try {\n *     if (data.value instanceof Error) {\n *       console.error('Error:', data.value);\n *     } else {\n *       console.log('Data:', data.value);\n *     }\n *   } catch (error) {\n *     console.error('Effect error:', error);\n *   }\n * });\n */\nexport class EffectImpl implements Disposable {\n    /**\n     * The computation that tracks dependencies and handles recomputation\n     */\n    private computation: Computation;\n\n    /**\n     * Cleanup function from the previous effect execution\n     */\n    private cleanup: Cleanup | undefined;\n\n    /**\n     * Flag indicating whether the effect has been disposed\n     */\n    private disposed = false;\n\n    /**\n     * Creates a new effect instance\n     *\n     * @param fn - The effect function that may return a cleanup function\n     * @param name - Optional name for debugging purposes\n     */\n    constructor(fn: EffectFunction, name?: string) {\n        this.computation = new class extends Computation {\n            // @ts-ignore\n            constructor(private effect: EffectImpl, private fn: EffectFunction) {\n                super(name);\n            }\n\n            /**\n             * Recomputes the effect when dependencies change\n             * Handles proper context management and error boundaries\n             */\n            recompute(): void {\n                if (this.disposed) return;\n\n                const context = SignalContext.getInstance();\n                context.pushComputation(this);\n\n                try {\n                    context.pushComputation(this);\n                    context.registerEffect(this.effect);\n                    this.effect.runEffect();\n                } finally {\n                    context.unregisterEffect(this.effect);\n                    context.popComputation();\n                    this.dirty = false;\n                }\n            }\n        }(this, fn);\n\n        // Initial computation\n        this.computation.recompute();\n    }\n\n    /**\n     * Disposes of the effect, running cleanup and preventing further executions\n     */\n    dispose(): void {\n        if (this.disposed) return;\n\n        this.disposed = true;\n        if (this.cleanup) {\n            try {\n                this.cleanup();\n            } catch (error) {\n                console.error('Error in effect cleanup:', error);\n            }\n        }\n        this.computation.dispose();\n    }\n\n    /**\n     * Executes the effect function and manages cleanup\n     * Handles error boundaries for both effect and cleanup execution\n     */\n    private runEffect(): void {\n        if (this.disposed) return;\n\n        // Run cleanup from previous execution\n        if (this.cleanup) {\n            try {\n                this.cleanup();\n            } catch (error) {\n                console.error('Error in effect cleanup:', error);\n            }\n        }\n\n        try {\n            // @ts-ignore - We know this exists from the constructor\n            this.cleanup = this.computation['fn']();\n        } catch (error) {\n            console.error('Error in effect:', error);\n            throw error;\n        }\n    }\n}\n\n/**\n * Creates a new effect that automatically tracks and responds to signal changes\n *\n * @param fn - Effect function that may return a cleanup function\n * @param name - Optional name for debugging purposes\n * @returns A disposable object to cleanup the effect\n *\n * @example\n * // DOM manipulation effect\n * const isVisible = new Signal(true);\n * const dispose = effect(() => {\n *   const element = document.querySelector('.target');\n *   element.style.display = isVisible.value ? 'block' : 'none';\n * });\n *\n * @example\n * // Effect with async operations\n * const userId = new Signal<number | null>(null);\n * const dispose = effect(() => {\n *   const id = userId.value;\n *   if (id !== null) {\n *     let cancelled = false;\n *     fetchUserData(id).then(data => {\n *       if (!cancelled) {\n *         // Handle data\n *       }\n *     });\n *     return () => {\n *       cancelled = true;\n *     };\n *   }\n * });\n */\nexport function effect(fn: EffectFunction, name?: string): Disposable {\n    return new EffectImpl(fn, name);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { createSignal } from './createSignal';\nimport { Signal } from './signal';\nimport { effect } from './effect';\n\n/**\n * Creates a debounced signal that updates its value after a specified delay\n * when the source signal changes.\n *\n * @param source Source signal to watch for changes\n * @param delay Time in milliseconds to wait before updating output\n * @param options Optional signal configuration\n *\n * @example\n * // Basic debouncing of rapid updates\n * const input = new Signal(\"\");\n * const debouncedInput = debounced(input, 300);\n *\n * input.value = \"h\";    // t=0ms\n * input.value = \"he\";   // t=100ms\n * input.value = \"hel\";  // t=200ms\n * input.value = \"hell\"; // t=250ms\n *\n * // debouncedInput.value will be \"hell\" at t=550ms\n *\n * @example\n * // Search input with debouncing\n * const searchQuery = new Signal(\"\");\n * const debouncedSearch = debounced(searchQuery, 500);\n *\n * effect(() => {\n *   // API call only happens 500ms after last keystroke\n *   fetchSearchResults(debouncedSearch.value);\n * });\n *\n * @example\n * // Form validation with debouncing\n * const formData = new Signal({ username: \"\", email: \"\" });\n * const debouncedForm = debounced(formData, 400, {\n *   equals: (a, b) => a.username === b.username && a.email === b.email\n * });\n *\n * effect(() => {\n *   // Validation runs 400ms after user stops typing\n *   validateForm(debouncedForm.value);\n * });\n */\nexport function debounced<T>(\n    source: Signal<T>,\n    delay: number,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const output = createSignal(source.value, options);\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    effect(() => {\n        const value = source.value;\n        if (timeoutId) clearTimeout(timeoutId);\n\n        timeoutId = setTimeout(() => {\n            output.value = value;\n        }, delay);\n\n        return () => {\n            if (timeoutId) clearTimeout(timeoutId);\n        };\n    });\n\n    return output;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { createSignal } from './createSignal';\nimport { Signal } from './signal';\nimport { effect } from './effect';\n\n/**\n * Creates a filtered signal that only updates when the predicate returns true.\n * The output signal follows the source signal's values but only changes when\n * the new value satisfies the given predicate.\n *\n * @param source The input signal to filter\n * @param predicate Function that determines if a value should pass through\n * @param options Optional configuration for the output signal\n * @returns A new signal that only updates when predicate returns true\n *\n * @example\n * const numbers = new Signal(0);\n * const evenNumbers = filtered(numbers, n => n % 2 === 0);\n * numbers.value = 1; // evenNumbers remains 0\n * numbers.value = 2; // evenNumbers updates to 2\n */\nexport function filtered<T>(\n    source: Signal<T>,\n    predicate: (value: T) => boolean,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const output = createSignal(source.value, options);\n\n    effect(() => {\n        const value = source.value;\n        if (predicate(value)) {\n            output.value = value;\n        }\n    });\n\n    return output;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport { effect } from './effect';\n\n/**\n * Debug utility to track signal updates\n */\nexport function debug<T>(signal: Signal<T>, name: string): Signal<T> {\n    effect(() => {\n        console.log(`[Signal Debug] ${name}:`, signal.value);\n    }, `debug-${name}`);\n    return signal;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { Signal } from './signal';\nimport { SignalContext } from './signalContext';\n\n\n/**\n * Retrieves the current value of a signal without establishing a dependency relationship.\n * This is useful when you want to read a signal's value without having the current computation\n * track it as a dependency, effectively \"peeking\" at the value without subscribing to changes.\n *\n * @template T The type of value held by the signal\n * @param signal The signal whose value you want to peek at\n * @returns The current value of the signal\n *\n * @description\n * The function works by temporarily manipulating the computation stack:\n * 1. Stores the current computation (if any) from the context\n * 2. Pushes undefined as a temporary computation to prevent dependency tracking\n * 3. Reads the signal's value\n * 4. Restores the previous computation state\n *\n * This approach ensures that when we read the signal's value, it won't be tracked\n * as a dependency in any active computation scope.\n *\n * @example\n * const counter = new Signal(0);\n * // Reading value normally would create a dependency\n * const normalRead = counter.value;\n * // Peeking at value doesn't create a dependency\n * const peekedValue = peek(counter);\n *\n * @example\n * // Useful in computed signals when you need a value for calculation\n * // but don't want to track changes to that specific signal\n * const total = computed(() => {\n *   const current = counter.value;  // Creates dependency\n *   const threshold = peek(maxValue);  // Reads value without dependency\n *   return current > threshold ? current : threshold;\n * });\n */\nexport function peek<T>(signal: Signal<T>): T {\n    const context = SignalContext.getInstance();\n    const prevComputation = context.getCurrentComputation();\n    // @ts-ignore\n    context.setCurrentComputation(undefined);\n    try {\n        return signal.get_value_bypass_tracking(); // Directly access value to bypass dependency tracking\n    } finally {\n        if (prevComputation) {\n            context.setCurrentComputation(prevComputation);\n        }\n    }\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { computed } from './computed';\nimport { Signal } from './signal';\nimport { peek } from './peek';\n\n/**\n * Creates a Signal that only updates when the source value changes by at least the specified delta.\n * Useful for filtering out small fluctuations in numeric values.\n *\n * @param source - Input Signal containing numeric values\n * @param delta - Minimum change required to trigger an update\n * @param options - Optional Signal configuration\n * @returns A new Signal that updates only on significant changes\n *\n * @example\n * const rawTemp = new Signal(20.0);\n * const filteredTemp = threshold(rawTemp, 0.5);\n * rawTemp.value = 20.2; // filteredTemp stays at 20.0\n * rawTemp.value = 20.6; // filteredTemp updates to 20.6\n */\nexport function threshold<T extends number>(\n    source: Signal<T>,\n    delta: number,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    return computed(() => {\n        const value = source.value;\n        const prevValue = peek(source);\n        return Math.abs(value - prevValue) >= delta ? value : prevValue;\n    }, {\n        ...options,\n        equals: (a, b) => Math.abs(a - b) < delta,\n    });\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { ComputedSignal } from './computedSignal';\nimport { UpdateQueue } from './updateQueue';\nimport { SignalMonitor } from './signalMonitor';\nimport { Signal } from './signal';\nimport { SignalContext } from './signalContext';\n\n/**\n * Default equality function for comparing signal values\n * Uses Object.is for strict equality comparison\n */\nexport const defaultEquals = <T>(a: T, b: T): boolean => Object.is(a, b);\n\n/**\n * Custom JSON serializer for signals\n * Useful for debugging and persistence\n */\nexport const serializeSignal = <T>(signal: Signal<T>): string => {\n    return JSON.stringify({\n        value: signal.value,\n        // @ts-ignore - accessing protected property for serialization\n        name: signal['name'],\n        // @ts-ignore - accessing protected property for serialization\n        disposed: signal['disposed'],\n    });\n};\n\n/**\n * Type guard to check if a value is a Signal\n */\nexport function isSignal<T>(value: any): value is Signal<T> {\n    return value instanceof Signal;\n}\n\n/**\n * Get the current computation depth of a signal chain\n */\nexport function getSignalDepth(signal: Signal<any>): number {\n    if (signal instanceof ComputedSignal) {\n        return signal.getDepth();\n    }\n    return 0;\n}\n\n/**\n * Check if a signal is part of a circular dependency chain\n */\nexport function hasCircularDependency(signal: Signal<any>): boolean {\n    const visited = new Set<Signal<any>>();\n    const recursionStack = new Set<Signal<any>>();\n\n    function dfs(current: Signal<any>): boolean {\n        if (recursionStack.has(current)) {\n            return true;\n        }\n        if (visited.has(current)) {\n            return false;\n        }\n\n        visited.add(current);\n        recursionStack.add(current);\n\n        // @ts-ignore - accessing protected property for cycle detection\n        const dependents = current['dependents'] || new Set();\n        for (const dependent of dependents) {\n            // @ts-ignore - accessing protected property for cycle detection\n            if (dependent['computation']?.signal && dfs(dependent['computation'].signal)) {\n                return true;\n            }\n        }\n\n        recursionStack.delete(current);\n        return false;\n    }\n\n    return dfs(signal);\n}\n\n/**\n * Reset the entire signal system state\n * Useful for testing and debugging\n */\nexport function resetSignalSystem(): void {\n    // @ts-ignore\n    SignalContext['instance'] = undefined;\n    // @ts-ignore\n    UpdateQueue['instance'] = undefined;\n    SignalMonitor.reset();\n}\n\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { createSignal } from './createSignal';\nimport { Signal } from './signal';\nimport { defaultEquals } from './utility';\nimport { batch } from './batch';\nimport { computed } from './computed';\n\n/**\n * Adds undo/redo functionality to a Signal by wrapping it with history tracking\n *\n * @param initialValue Initial value for the signal\n * @param maxHistory Maximum number of history states to maintain\n * @param options Signal configuration options\n * @returns Enhanced signal with undo/redo capabilities and history access\n */\nexport function withHistory<T>(\n    initialValue: T,\n    maxHistory: number = 10,\n    options?: SignalOptions<T>,\n): Signal<T> & {\n    undo(): void;\n    redo(): void;\n    history: Signal<T[]>;\n    canUndo: Signal<boolean>;\n    canRedo: Signal<boolean>;\n} {\n    // Use provided equals function or default\n    const equalsFn = options?.equals ?? defaultEquals;\n\n    const signal = createSignal(initialValue, {\n        ...options,\n        equals: equalsFn, // Ensure equals function is properly passed\n    });\n    const history = createSignal<T[]>([initialValue]);\n    const currentIndex = createSignal(0);\n\n    const canUndo = computed(() => currentIndex.value > 0);\n    const canRedo = computed(() => currentIndex.value < history.value.length - 1);\n\n    const wrapper = Object.create(signal) as Signal<T> & {\n        undo(): void;\n        redo(): void;\n        history: Signal<T[]>;\n        canUndo: Signal<boolean>;\n        canRedo: Signal<boolean>;\n    };\n\n    wrapper.history = history;\n    wrapper.canUndo = canUndo;\n    wrapper.canRedo = canRedo;\n\n    // Use batch for atomic updates\n    Object.defineProperty(wrapper, 'value', {\n        get: () => signal.value,\n        set: (newValue: T) => {\n            if (!equalsFn(signal.value, newValue)) {\n                batch(() => {\n                    const newIndex = currentIndex.value + 1;\n                    const newHistory = history.value\n                        .slice(0, newIndex)\n                        .concat([newValue]);\n\n                    if (newHistory.length > maxHistory) {\n                        newHistory.shift();\n                        currentIndex.value = newIndex - 1;\n                    } else {\n                        currentIndex.value = newIndex;\n                    }\n\n                    history.value = newHistory;\n                    signal.value = newValue;\n                });\n            }\n        },\n    });\n\n    wrapper.undo = () => {\n        if (canUndo.value) {\n            batch(() => {\n                currentIndex.value--;\n                signal.value = history.value[currentIndex.value] as T;\n            });\n        }\n    };\n\n    wrapper.redo = () => {\n        if (canRedo.value) {\n            batch(() => {\n                currentIndex.value++;\n                signal.value = history.value[currentIndex.value] as T;\n            });\n        }\n    };\n\n    return wrapper;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\nimport { SignalOptions } from './interfaces';\nimport { createSignal } from './createSignal';\nimport { effect } from './effect';\nimport { Signal } from './signal';\n\n/**\n * Create a signal that throttles updates\n */\nexport function throttled<T>(\n    source: Signal<T>,\n    interval: number,\n    options?: SignalOptions<T>,\n): Signal<T> {\n    const output = createSignal(source.value, options);\n    let lastUpdate = 0;\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    effect(() => {\n        const value = source.value;\n        const now = Date.now();\n\n        if (now - lastUpdate >= interval) {\n            output.value = value;\n            lastUpdate = now;\n        } else if (!timeoutId) {\n            timeoutId = setTimeout(() => {\n                output.value = value;\n                lastUpdate = Date.now();\n                timeoutId = undefined;\n            }, interval - (now - lastUpdate));\n        }\n\n        return () => {\n            if (timeoutId) clearTimeout(timeoutId);\n        };\n    });\n\n    return output;\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer\n *\n * Defines storage provider interfaces and implementations for persisting signal values\n * across browser sessions and environments.\n */\n\nimport { SignalOptions } from './interfaces';\nimport { Signal } from './signal';\nimport { effect } from './effect';\nimport { SignalDisposedError } from './errors';\n\n/**\n * Interface for storage providers to get, set and remove persisted values\n */\nexport interface StorageProvider<T> {\n    /** Retrieves value by key, returns null if not found */\n    getItem(key: string): T | null;\n\n    /** Stores value with given key */\n    setItem(key: string, value: T): void;\n\n    /** Removes value with given key */\n    removeItem(key: string): void;\n}\n\n/**\n * Uses browser localStorage for persistent storage across sessions\n * Falls back gracefully when not in browser environment\n */\nexport class LocalStorageProvider<T> implements StorageProvider<T> {\n    /**\n     * Gets item from localStorage\n     * @param key - Key to retrieve\n     * @returns Stored value or null if not found/not in browser\n     */\n    getItem(key: string): T | null {\n        if (typeof window === 'undefined') return null;\n        const presented = window.localStorage.getItem(key);\n        if (presented) {\n            return JSON.parse(presented);\n        }\n        return null;\n    }\n\n    /**\n     * Sets item in localStorage\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    setItem(key: string, value: T): void {\n        if (typeof window === 'undefined') return;\n        window.localStorage.setItem(key, JSON.stringify(value));\n    }\n\n    /**\n     * Removes item from localStorage\n     * @param key - Key to remove\n     */\n    removeItem(key: string): void {\n        if (typeof window === 'undefined') return;\n        window.localStorage.removeItem(key);\n    }\n}\n\n/**\n * Uses browser sessionStorage for temporary storage during session\n * Falls back gracefully when not in browser environment\n */\nexport class SessionStorageProvider<T> implements StorageProvider<T> {\n    /**\n     * Gets item from sessionStorage\n     * @param key - Key to retrieve\n     * @returns Stored value or null if not found/not in browser\n     */\n    getItem(key: string): T | null {\n        if (typeof window === 'undefined') return null;\n        const presented = window.sessionStorage.getItem(key);\n        if (presented) {\n            return JSON.parse(presented);\n        }\n        return null;\n    }\n\n    /**\n     * Sets item in sessionStorage\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    setItem(key: string, value: T): void {\n        if (typeof window === 'undefined') return;\n        window.sessionStorage.setItem(key, JSON.stringify(value));\n    }\n\n    /**\n     * Removes item from sessionStorage\n     * @param key - Key to remove\n     */\n    removeItem(key: string): void {\n        if (typeof window === 'undefined') return;\n        window.sessionStorage.removeItem(key);\n    }\n}\n\n/**\n * In-memory storage provider for testing and SSR environments\n * Data persists only during runtime\n */\nexport class MemoryStorageProvider<T> implements StorageProvider<T> {\n    /** Map to store key-value pairs in memory */\n    private store = new Map<string, T>();\n\n    /**\n     * Gets item from memory store\n     * @param key - Key to retrieve\n     * @returns Stored value or null if not found\n     */\n    getItem(key: string): T | null {\n        return this.store.get(key) ?? null;\n    }\n\n    /**\n     * Sets item in memory store\n     * @param key - Key to store under\n     * @param value - Value to store\n     */\n    setItem(key: string, value: T): void {\n        this.store.set(key, value);\n    }\n\n    /**\n     * Removes item from memory store\n     * @param key - Key to remove\n     */\n    removeItem(key: string): void {\n        this.store.delete(key);\n    }\n}\n\n\nexport type PersistedSignalStorage<T> = {\n    storage?: StorageProvider<T>;\n}\n\nexport type PersistedSignalSignalOptions<T> = SignalOptions<T> & PersistedSignalStorage<T>;\n\nexport class Persisted<T> extends Signal<T> {\n    disposed = false;\n    private readonly storage: StorageProvider<T>;\n    private readonly key: string;\n\n    constructor(\n        key: string,\n        initialValue: T,\n        storage: StorageProvider<T>,\n        options?: SignalOptions<T>,\n    ) {\n        const storedValue = storage.getItem(key);\n        super(storedValue ?? initialValue, options);\n\n        this.key = key;\n        this.storage = storage;\n\n        effect(() => {\n            if (this.disposed) return;\n            this.storage.setItem(this.key, this.value);\n        }, `persist-${key}`);\n    }\n\n    get value(): T {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot read from disposed signal');\n        }\n        return super.value;\n    }\n\n    set value(newValue: T) {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot write to disposed signal');\n        }\n        super.value = newValue;\n    }\n\n    update(fn: (current: T) => T): void {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot update disposed signal');\n        }\n        this.value = fn(this.value);\n    }\n\n    dispose(): void {\n        if (this.disposed) return;\n        this.disposed = true;\n        this.storage.removeItem(this.key);\n        super.dispose();\n    }\n\n    reload(): void {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot reload disposed signal');\n        }\n        const value = this.storage.getItem(this.key);\n        if (value !== null) {\n            this.value = value;\n        }\n    }\n\n    clear(): void {\n        if (this.disposed) {\n            throw new SignalDisposedError('Cannot clear disposed signal');\n        }\n        this.storage.removeItem(this.key);\n    }\n\n    isDisposed(): boolean {\n        return this.disposed;\n    }\n}\n\nexport function persisted<T>(\n    key: string,\n    initialValue: T,\n    storage: StorageProvider<T>,\n    options?: SignalOptions<T>,\n): Persisted<T> {\n    return new Persisted(key, initialValue, storage, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\n\n\nimport { Signal } from './signal';\nimport { SignalOptions } from './interfaces';\n\n/**\n * Represents the state of an asynchronous operation\n * @template T The type of data being fetched\n * @template E The type of error (defaults to Error)\n */\nexport interface AsyncState<T, E = Error> {\n    /** The fetched data */\n    data: T | null;\n    /** Whether a fetch is in progress */\n    loading: boolean;\n    /** Any error that occurred during fetch */\n    error: E | null;\n    /** When the data was last fetched */\n    timestamp: number;\n}\n\n/**\n * Configuration options for AsyncSignal\n * @template T The type of data being fetched\n * @template E The type of error\n *\n * @example\n * // Basic caching config\n * const options: AsyncSignalOptions<User> = {\n *   cache: {\n *     enabled: true,\n *     ttl: 5 * 60 * 1000 // 5 minutes\n *   }\n * };\n *\n * @example\n * // Retry with exponential backoff\n * const options: AsyncSignalOptions<User> = {\n *   retryConfig: {\n *     attempts: 3,      // Try 3 times\n *     delay: 1000,      // Start with 1s delay\n *     backoffFactor: 2  // Double delay each retry: 1s, 2s, 4s\n *   }\n * };\n *\n * @example\n * // With analytics callbacks\n * const options: AsyncSignalOptions<User> = {\n *   onSuccess: (user) => {\n *     analytics.track('userFetched', { userId: user.id });\n *     updateUI(user);\n *   },\n *   onError: (error) => {\n *     errorReporting.capture(error);\n *     showErrorToast(error.message);\n *   }\n * };\n */\nexport interface AsyncSignalOptions<T, E = Error> extends SignalOptions<AsyncState<T, E>> {\n    cache?: {\n        enabled: boolean;   //\n        ttl?: number;      // How long to cache results (ms)\n    };\n    retryConfig?: {\n        attempts: number;    // Maximum retry attempts\n        delay: number;      // Initial delay between retries (ms)\n        backoffFactor: number; // How much to increase delay each retry\n    };\n    onError?: (error: E) => void;    // Error callback\n    onSuccess?: (data: T) => void;   // Success callback\n}\n\n/**\n * A Signal subclass for managing asynchronous operations with built-in\n * loading states, caching, and retry logic\n *\n * @template T Type of data being fetched\n * @template E Type of error that can occur\n *\n * @example\n * // User authentication with error handling\n * interface User {\n *   id: string;\n *   name: string;\n *   email: string;\n * }\n *\n * interface AuthError {\n *   code: 'invalid_credentials' | 'network_error' | 'server_error';\n *   message: string;\n * }\n *\n * const authSignal = new AsyncSignal<User, AuthError>(\n *   async () => {\n *     const response = await fetch('/api/auth');\n *     if (!response.ok) {\n *       throw {\n *         code: 'invalid_credentials',\n *         message: 'Invalid username or password'\n *       };\n *     }\n *     return response.json();\n *   },\n *   {\n *     cache: { enabled: true, ttl: 30 * 60 * 1000 }, // 30min cache\n *     onError: (error) => {\n *       if (error.code === 'invalid_credentials') {\n *         showLoginForm();\n *       } else {\n *         showErrorDialog(error.message);\n *       }\n *     }\n *   }\n * );\n *\n * @example\n * // Real-time search with request cancellation\n * const searchSignal = new AsyncSignal(\n *   async (query: string) => {\n *     const response = await fetch(`/api/search?q=${query}`);\n *     return response.json();\n *   }\n * );\n *\n * searchInput.addEventListener('input', async (e) => {\n *   const results = await searchSignal.fetch(); // Auto-cancels previous\n *   updateSearchResults(results);\n * });\n *\n * @example\n * // File upload with progress tracking\n * const uploadSignal = new AsyncSignal<string>(\n *   async (file: File) => {\n *     const formData = new FormData();\n *     formData.append('file', file);\n *\n *     const response = await fetch('/api/upload', {\n *       method: 'POST',\n *       body: formData\n *     });\n *\n *     if (!response.ok) {\n *       throw new Error('Upload failed');\n *     }\n *\n *     const { url } = await response.json();\n *     return url;\n *   },\n *   {\n *     retryConfig: {\n *       attempts: 3,\n *       delay: 2000,\n *       backoffFactor: 1.5\n *     },\n *     onSuccess: (url) => {\n *       showSuccess(`File uploaded to ${url}`);\n *     }\n *   }\n * );\n *\n * @example\n * // Polling with caching\n * const pollSignal = new AsyncSignal<JobStatus>(\n *   async (jobId: string) => {\n *     const response = await fetch(`/api/jobs/${jobId}`);\n *     return response.json();\n *   },\n *   {\n *     cache: {\n *       enabled: true,\n *       ttl: 5000 // Cache for 5s between polls\n *     }\n *   }\n * );\n *\n * const pollJob = async (jobId: string) => {\n *   while (true) {\n *     const status = await pollSignal.fetch();\n *     if (status.state === 'completed') break;\n *     await new Promise(resolve => setTimeout(resolve, 5000));\n *   }\n * };\n */\nexport class AsyncSignal<T, E = Error> extends Signal<AsyncState<T, E>> {\n    private readonly fetchFn: () => Promise<T>;\n    private options: AsyncSignalOptions<T, E>;\n    private abortController: AbortController | null = null;\n\n    constructor(\n        fetchFn: () => Promise<T>,\n        options: AsyncSignalOptions<T, E> = {},\n    ) {\n        super({\n            data: null,\n            loading: false,\n            error: null,\n            timestamp: 0,\n        }, options);\n\n        this.fetchFn = fetchFn;\n        this.options = options;\n    }\n\n    /**\n     * Fetches data using the provided fetch function\n     * Handles loading states, caching, retries, and error handling\n     *\n     * @param force Whether to bypass cache and force a new fetch\n     * @returns The fetched data or null if fetch failed\n     *\n     * @example\n     * const signal = new AsyncSignal(fetchUser);\n     * await signal.fetch(); // Normal fetch, uses cache if valid\n     * await signal.fetch(true); // Force fetch, bypass cache\n     */\n    async fetch(force: boolean = false): Promise<T | null> {\n        // Check cache unless forced refresh\n        if (this.isCacheValid() && !force) {\n            return this.value.data;\n        }\n\n        // Cancel any in-flight request\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n        this.abortController = new AbortController();\n\n        // Set loading state\n        this.value = {\n            ...this.value,\n            loading: true,\n            error: null,\n        };\n\n        // Initialize retry loop variables\n        let attempts = 0;\n        const maxAttempts = this.options.retryConfig?.attempts || 1;\n        const delay = this.options.retryConfig?.delay || 1000;\n        const backoffFactor = this.options.retryConfig?.backoffFactor || 2;\n\n        // Retry loop\n        while (attempts < maxAttempts) {\n            try {\n                const data = await this.fetchFn();\n                // Update state on success\n                this.value = {\n                    data,\n                    loading: false,\n                    error: null,\n                    timestamp: Date.now(),\n                };\n                this.options.onSuccess?.(data);\n                return data;\n            } catch (error) {\n                attempts++;\n                // If out of retries, set error state\n                if (attempts === maxAttempts) {\n                    this.value = {\n                        ...this.value,\n                        loading: false,\n                        error: error as E,\n                    };\n                    this.options.onError?.(error as E);\n                    return null;\n                }\n                // Wait before retrying with exponential backoff\n                await new Promise(resolve =>\n                    setTimeout(resolve, delay * Math.pow(backoffFactor, attempts - 1)),\n                );\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Forces a fresh fetch, bypassing cache\n     */\n    refresh(): Promise<T | null> {\n        return this.fetch(true);\n    }\n\n    /**\n     * Cleans up by aborting any in-flight request\n     */\n    override dispose(): void {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n        super.dispose();\n    }\n\n    /**\n     * Checks if cached data is still valid based on TTL\n     */\n    private isCacheValid(): boolean {\n        if (!this.options.cache?.enabled) return false;\n        if (!this.value.data) return false;\n\n        const ttl = this.options.cache.ttl || 5 * 60 * 1000; // Default 5 minutes\n        return Date.now() - this.value.timestamp < ttl;\n    }\n}\n\n/**\n * Factory function to create AsyncSignal instances\n *\n * @example\n * // Example 1: Simple user fetch with caching\n * const userSignal = asyncSignal(\n *   async () => {\n *     const response = await fetch('/api/user');\n *     return response.json();\n *   },\n *   {\n *     cache: { enabled: true, ttl: 60000 } // Cache for 1 minute\n *   }\n * );\n *\n * @example\n * // Example 2: Weather API with retries\n * const weatherSignal = asyncSignal(\n *   async () => {\n *     const response = await fetch('https://api.weather.com/current');\n *     return response.json();\n *   },\n *   {\n *     retryConfig: {\n *       attempts: 3,\n *       delay: 1000,\n *       backoffFactor: 2\n *     }\n *   }\n * );\n *\n * @example\n * // Example 3: Todo list with error handling\n * const todoSignal = asyncSignal(\n *   async () => {\n *     const response = await fetch('/api/todos');\n *     if (!response.ok) throw new Error('Failed to fetch todos');\n *     return response.json();\n *   },\n *   {\n *     onError: (error) => console.error('Todo fetch failed:', error),\n *     onSuccess: (todos) => console.log('Fetched todos:', todos.length)\n *   }\n * );\n */\nexport function asyncSignal<T, E = Error>(\n    fetchFn: () => Promise<T>,\n    options?: AsyncSignalOptions<T, E>,\n): AsyncSignal<T, E> {\n    return new AsyncSignal(fetchFn, options);\n}\n","/**\n * Copyright (c) 2024 Khaled Sameer <khaled.smq@hotmail.com>.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n **/\nimport { Signal } from './signal';\nimport { createSignal } from './createSignal';\n\n/**\n * Represents an item in the queue with priority and timestamp.\n */\nexport interface QueueItem<T> {\n    id: string;          // Unique identifier for the item\n    data: T;            // The actual data stored in the queue\n    priority: number;   // Priority level (higher numbers = higher priority)\n    timestamp: number;  // Used for FIFO ordering within same priority\n}\n\n/**\n * A priority queue implementation using signals for reactive state management.\n * Items are ordered by priority (highest first) and timestamp (FIFO for same priority).\n *\n * @example\n * // Basic queue operations\n * const taskQueue = createQueueSignal<string>();\n *\n * // Add tasks with different priorities\n * taskQueue.enqueue(\"Low priority task\", 1);\n * taskQueue.enqueue(\"High priority task\", 3);\n * taskQueue.enqueue(\"Medium priority task\", 2);\n *\n * console.log(taskQueue.peek()); // \"High priority task\"\n * console.log(taskQueue.dequeue()); // \"High priority task\"\n * console.log(taskQueue.size()); // 2\n *\n * @example\n * // Task processing with priorities\n * const processingQueue = createQueueSignal<{task: string, urgency: string}>();\n *\n * // Emergency task (priority 3)\n * const emergencyId = processingQueue.enqueue(\n *   {task: \"Server down\", urgency: \"high\"},\n *   3\n * );\n *\n * // Regular tasks (priority 1)\n * processingQueue.enqueue({task: \"Update docs\", urgency: \"low\"}, 1);\n * processingQueue.enqueue({task: \"Code review\", urgency: \"low\"}, 1);\n *\n * // Process emergency first\n * while (!processingQueue.isEmpty()) {\n *   const task = processingQueue.dequeue();\n *   console.log(`Processing: ${task.task}`);\n * }\n *\n * @example\n * // Reactive queue monitoring\n * const downloadQueue = createQueueSignal<string>();\n * const queueSignal = downloadQueue.getQueue();\n *\n * effect(() => {\n *   const items = queueSignal.value;\n *   console.log(`Queue size changed: ${items.length} items`);\n * });\n *\n * downloadQueue.enqueue(\"file1.txt\");\n * downloadQueue.enqueue(\"file2.txt\");\n */\nexport class QueueSignal<T> {\n    private queue: Signal<QueueItem<T>[]>;\n\n    constructor() {\n        this.queue = createSignal<QueueItem<T>[]>([]);\n    }\n\n    /**\n     * Adds an item to the queue with optional priority.\n     * @param data The item to add\n     * @param priority Priority level (higher = more priority)\n     * @returns Unique ID for the queued item\n     */\n    enqueue(data: T, priority: number = 0): string {\n        const id = Math.random().toString(36).substring(2);\n        const item: QueueItem<T> = {\n            id,\n            data,\n            priority,\n            timestamp: Date.now(),\n        };\n\n        this.queue.value = [...this.queue.value, item].sort(\n            (a, b) => b.priority - a.priority || a.timestamp - b.timestamp,\n        );\n\n        return id;\n    }\n\n    /**\n     * Removes and returns the highest priority item.\n     * @returns The data of the dequeued item, or undefined if queue is empty\n     */\n    dequeue(): T | undefined {\n        if (this.isEmpty()) return undefined;\n        const [item, ...rest] = this.queue.value;\n        this.queue.value = rest;\n        return item?.data;\n    }\n\n    /**\n     * Views the next item without removing it.\n     * @returns The data of the next item, or undefined if queue is empty\n     */\n    peek(): T | undefined {\n        return this.queue.value[0]?.data;\n    }\n\n    /**\n     * Removes a specific item by its ID.\n     * @param id ID of the item to remove\n     * @returns true if an item was removed, false otherwise\n     */\n    remove(id: string): boolean {\n        const initialLength = this.queue.value.length;\n        this.queue.value = this.queue.value.filter(item => item.id !== id);\n        return initialLength !== this.queue.value.length;\n    }\n\n    /**\n     * Removes all items from the queue.\n     */\n    clear(): void {\n        this.queue.value = [];\n    }\n\n    /**\n     * Checks if the queue is empty.\n     */\n    isEmpty(): boolean {\n        return this.queue.value.length === 0;\n    }\n\n    /**\n     * Returns the number of items in the queue.\n     */\n    size(): number {\n        return this.queue.value.length;\n    }\n\n    /**\n     * Gets the underlying signal for reactive queue monitoring.\n     * @returns Signal containing the queue items\n     */\n    getQueue(): Signal<QueueItem<T>[]> {\n        return this.queue;\n    }\n}\n\n/**\n * Creates a new queue signal instance.\n * @example\n * // Basic queue operations\n * const taskQueue = createQueueSignal<string>();\n *\n * // Add tasks with different priorities\n * taskQueue.enqueue(\"Low priority task\", 1);\n * taskQueue.enqueue(\"High priority task\", 3);\n * taskQueue.enqueue(\"Medium priority task\", 2);\n *\n * console.log(taskQueue.peek()); // \"High priority task\"\n * console.log(taskQueue.dequeue()); // \"High priority task\"\n * console.log(taskQueue.size()); // 2\n *\n * @example\n * // Task processing with priorities\n * const processingQueue = createQueueSignal<{task: string, urgency: string}>();\n *\n * // Emergency task (priority 3)\n * const emergencyId = processingQueue.enqueue(\n *   {task: \"Server down\", urgency: \"high\"},\n *   3\n * );\n *\n * // Regular tasks (priority 1)\n * processingQueue.enqueue({task: \"Update docs\", urgency: \"low\"}, 1);\n * processingQueue.enqueue({task: \"Code review\", urgency: \"low\"}, 1);\n *\n * // Process emergency first\n * while (!processingQueue.isEmpty()) {\n *   const task = processingQueue.dequeue();\n *   console.log(`Processing: ${task.task}`);\n * }\n *\n * @example\n * // Reactive queue monitoring\n * const downloadQueue = createQueueSignal<string>();\n * const queueSignal = downloadQueue.getQueue();\n *\n * effect(() => {\n *   const items = queueSignal.value;\n *   console.log(`Queue size changed: ${items.length} items`);\n * });\n *\n * @returns A new QueueSignal instance\n */\nexport function createQueueSignal<T>(): QueueSignal<T> {\n    return new QueueSignal<T>();\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","SignalContext","computationStack","batchDepth","batchQueue","Set","activeEffects","getInstance","instance","getCurrentComputation","length","pushComputation","computation","includes","push","popComputation","pop","isBatching","beginBatch","endBatch","flushBatchQueue","addToBatchQueue","signal","add","uniqueSignals","clear","computations","dependent","getDependents","markDirty","setCurrentComputation","registerEffect","effect","unregisterEffect","delete","isInEffect","size","batch","fn","context","UpdateQueue","queue","processing","updateDepth","maxUpdateDepth","schedule","Error","processQueue","Array","from","sort","a","b","getDepth","isDirty","isDisposed","recompute","Computation","constructor","name","dirty","disposed","dependencies","dependents","depth","addDependency","has","ComputedSignal","removeDependency","dispose","clearDependencies","hasSignal","dep","removeDependent","oldDepth","maxDepth","Math","max","SignalDisposedError","operation","super","CircularDependencyError","signalName","Signal","initialValue","options","_value","equals","is","trackDependency","newValue","notifyDependents","get_value_bypass_tracking","update","subscribe","callback","computed","addDependent","dependentsToDispose","hasDependents","toString","compute","undefined","computeFn","prevComputation","error","_","combine","signals","map","s","prev","next","every","val","idx","join","SignalMonitor","trackUpdate","duration","metrics","updates","updateTimes","shift","averageUpdateTime","reduce","trackComputation","maxChainDepth","getMetrics","reset","createSignal","validated","validator","innerSignal","validationError","result","Proxy","target","set","source","transform","EffectImpl","runEffect","cleanup","console","debounced","delay","output","timeoutId","clearTimeout","setTimeout","filtered","predicate","debug","log","peek","threshold","delta","prevValue","abs","defaultEquals","serializeSignal","JSON","stringify","isSignal","getSignalDepth","hasCircularDependency","visited","recursionStack","dfs","current","resetSignalSystem","withHistory","maxHistory","equalsFn","history","currentIndex","canUndo","canRedo","wrapper","create","newIndex","newHistory","slice","concat","undo","redo","throttled","interval","lastUpdate","now","Date","LocalStorageProvider","getItem","window","presented","localStorage","parse","setItem","removeItem","SessionStorageProvider","sessionStorage","MemoryStorageProvider","store","Map","Persisted","storage","storedValue","reload","persisted","AsyncSignal","fetchFn","data","loading","timestamp","abortController","fetch","force","isCacheValid","abort","AbortController","attempts","maxAttempts","retryConfig","backoffFactor","onSuccess","onError","Promise","resolve","pow","refresh","cache","enabled","ttl","asyncSignal","QueueSignal","enqueue","priority","id","random","substring","item","dequeue","isEmpty","rest","remove","initialLength","filter","getQueue","createQueueSignal"],"sourceRoot":""}